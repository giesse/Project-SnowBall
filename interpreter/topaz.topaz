error: function [type message where] [] [
    throw join "*** " join type join " error: " join message join "^/*** Where: " where
]

datatype!: none

make-type: function [name] [] [
    make-struct [
        type: datatype!
        name: name
        make: none
        insert: none
        head: none
        pick: none
        length-of: none
    ]
]
datatype!: make-type "datatype!"
datatype!/type: datatype!

make: function [type arguments] [] [
    apply 'type/make [arguments]
]
insert: function [series value] [] [
    apply 'series/type/insert [series value]
]
head: function [series] [] [
    apply 'series/type/head [series]
]
pick: function [series pos] [] [
    apply 'series/type/pick [series pos]
]
length-of: function [series] [] [
    apply 'series/type/length-of [series]
]
empty?: function [series] [] [
    0 = length-of series
]

block!: make-type "block!"
block!/make: function [arguments] [] [
    make-struct [
        type: block!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
block!/insert: function [block value] [] [
    make-struct [
        type: block!
        values: insert-array block/values block/pos value
        pos: block/pos + 1
        newlines: insert-array block/newlines block/pos false
    ]
]
block!/head: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
block!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
block!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]

string!: make-type "string!"
string!/make: function [arguments] [] [
    make-struct [
        type: string!
        string: arguments
        pos: 0
    ]
]
string!/length-of: function [string] [] [
    (length-of-array string/string) - string/pos
]
string!/pick: function [string pos] [] [
    pick-array string/string string/pos + pos
]

first: function [series] [] [
    pick series 0
]

new-line: function [block newline?] [] [
    poke-array block/newlines block/pos newline?
]

match-c: function [text chset] [t] [
    t: length-of-array pick-array apply 'chset/exec [apply 'text/string/substr [text/pos]] 0
    text/pos: text/pos + t
    t > 0
]
match-s: function [text str] [] [
    if str = apply 'text/string/substr [text/pos length-of-array str] [
        text/pos: text/pos + length-of-array str
        true
    ]
]

skip-spaces: function [text] [newline?] [
    until [
        not any [
            match-c text charset " ^-"
            all [match-s text "^/" newline?: true]
        ]
    ]
    reduce [text newline?]
]

empty-array?: function [array] [] [
    0 = length-of-array array
]

parse-value: function [text] [] [
    reduce [none text]
]

parse-values: function [text] [values value newline?] [
    values: make block! none
    set [text newline?] skip-spaces text
    new-line values newline?
    while [all [not empty? text  #"]" = first text]] [
        set [value text] parse-value text
        either value [
            set [text newline?] skip-spaces text
            values: insert values value
            new-line values newline?
        ] [
            error "Syntax" "Parse error" text/string
        ]
    ]
    reduce [head values text]
]

bind: function [words context extend?] [] [
    words
]

system-words: none

load: function [text] [values] [
    set [values text] parse-values text
    if not empty? text [
        error "Syntax" "Parse error" text/string
    ]
    bind values system-words true
    either 1 = length-of values [
        first values
    ] [
        values
    ]
]
