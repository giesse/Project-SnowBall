Parser (front-end) for the Topaz language compiler

    Type: Module
    Purpose: {
        Parses a Topaz code block into a tree.
    }
    Author: "Gabriele Santilli"
    File: %parser.r
    Version: 1.0.0
    Imports: [
        %bootstrap/niwashi.r
        %bootstrap/trees.r
        %bootstrap/collect.r
        %compiler/specials.r
    ]
    Exports: [
        parse-code-block
    ]

===Introduction

This program parses a Topaz code block or function into a tree. Documentation is still scarce
(and will probably stay this way until successful compiler bootstrap).

===Overview

The function returns a tree that represents the code in the passed code block.

    -main-:
    -support-functions-

    parse-code-block: func [
        "Parse a Topaz code block into a tree"
        code [block! function!]
        rules [block! none!] "Optional niwashi rules"

        /local -pcb-locals-
    ] [
        -parse-code-block-
    ]

===Parse |code| and build a tree to represent the code in it

    -parse-code-block-:
    ctx: make-context
    if function? :code [
        define-arguments ctx :code
        code: second :code
    ]
    if rules [
        ctx/rules: rules
        define-rules ctx/niwashi rules
    ]
    parse-block ctx code
    ctx/niwashi/root

---|parse-code-block|'s locals

    -pcb-locals-:
    ctx

===Support functions

    -support-functions-:
    -context-
    -parser-actions-
    -parse-block-
    -parse-word-
    -helpers-

---Parser context functions

    -context-:
    make-context: does [
        context [
            rules: none
            niwashi: make-niwashi
            words: [ ]
        ]
    ]
    define-arguments: func [ctx [object!] f [function!] /local arg types] [
        ctx/words: collect [
            parse third :f [
                any string! opt block!
                any [
                    set arg word! set types opt block! (
                        keep arg
                        keep/only any [types 'any]
                    )
                    |
                    set arg refinement! (
                        keep to word! arg
                        keep/only reduce [logic! none!]
                    )
                    |
                    string!
                ]
            ]
        ]
    ]

---Parser engine

    -parse-block-:
    parse-block: func [ctx [object!] code [any-block!]] [
        while [not empty? code] [
            code: parse-step ctx code
        ]
        ctx
    ]
    parse-step: func [ctx [object!] code [any-block!]] [
        ; Fixme: op!
        parser-actions/(type?/word pick code 1)/parse-value ctx pick code 1 next code
    ]

---Parser actions for each data type

    -parser-actions-:
    parse-default: func [ctx [object!] value cont [any-block!]] [
        append-child ctx/niwashi [type: type?/word :value properties: [value: :value]]
        cont
    ]
    parser-actions: context collect [
        foreach value second system/words [
            if datatype? get/any 'value [
                keep to set-word! to word! value
                keep [context [parse-value: :parse-default]]
            ]
        ]
    ]

+++|paren!|

    -parser-actions-:
    parser-actions/paren!/parse-value: func [ctx [object!] paren cont [any-block!]] [
        enter-child ctx/niwashi [type: 'paren!]
        parse-block ctx paren
        leave-child ctx/niwashi
        cont
    ]

+++|path!|

    -parser-actions-:
    parser-actions/path!/parse-value: func [ctx [object!] path cont [any-block!]] [
        parse-word ctx first path next path cont
    ]

+++|set-path!| and |set-word!|

Fixme: |set-path!| not really this simple

    -parser-actions-:
    parser-actions/set-path!/parse-value:
    parser-actions/set-word!/parse-value: func [ctx [object!] value cont [any-block!]] [
        ; Fixme: need to handle the argument case (common: locals)
        ; (also the argument case needs to use unique words as otherwise they might get rebound (macros))
        enter-child ctx/niwashi [type: type?/word value properties: [value: value]]
        cont: parse-step ctx cont
        leave-child ctx/niwashi
        cont
    ]

+++|word!|

Fixme: need to consider |get 'word| (eg. macro)

    -parser-actions-:
    parser-actions/word!/parse-value: func [ctx [object!] word cont [any-block!]] [
        parse-word ctx word none cont
    ]

+++|get-word!|

Fixme

---Word values parser (arguments, variables, functions, etc.)

    -parse-word-:
    parse-word: func [
        ctx [object!] word [word!] rest [path! none!] cont [any-block!]
        /local types f refs parse-special
    ] [
        case [
            types: argument? word ctx [
                parse-argument ctx types word rest cont
            ]
            parse-special: special? word [
                parse-special ctx word rest cont
            ]
            (set [f refs] resolve-path get/any word rest
            any-function? :f) [
                either macro? :f [
                    parse-macro ctx :f refs cont
                ] [
                    parse-function ctx :f either refs [head rest] [:f] refs cont
                ]
            ]
            'else [
                append-child ctx/niwashi either rest [
                    [type: 'path! properties: [value: head rest]]
                ] [
                    [type: 'word! properties: [value: word]]
                ]
                cont
            ]
        ]
    ]

+++Arguments

    -parse-word-:
    argument?: func [word [word!] ctx [object!]] [
        select ctx/words word
    ]
    parse-argument: func [ctx [object!] types [block! word!] word [word!] rest [path! none!] cont [any-block!]] [
        ; Fixme: check types? eg. when rest not none
        append-child ctx/niwashi [
            type: 'argument
            properties: [
                value: either rest [head rest] [word]
                types: types
            ]
        ]
        cont
    ]

+++Special functions

    -parse-word-:
    special?: func [word [word!]] [
        if value? word [
            if native? word: get word [
                word: mold third :word
            ]
            select specials :word
        ]
    ]
    specials: reduce [
        -specials-
    ]
    ; work around FIND not being able to find NATIVE! values
    forall specials [
        if native? pick specials 1 [
            specials/1: mold third pick specials 1
        ]
    ]

+++Path resolution

    -parse-word-:
    resolve-path: func [value [any-type!] rest [path! none!]] [
        if all [path? rest empty? rest] [rest: none]
        switch/default type?/word get/any 'value [
            function! native! action! [
                reduce [:value rest]
            ]
            object! [
                either all [
                    path? rest
                    value: get in value first rest
                ] [
                    resolve-path :value next rest
                ] [
                    [#[none] #[none]]
                ]
            ]
        ] [
            [#[none] #[none]]
        ]
    ]

+++Macros

    -parse-word-:
    macro?: func [f [any-function!]] [
        parse third :f [
            any string! into [to 'macro to end] to end
        ]
    ]
    parse-macro: func [
        ctx [object!]
        f [function!]
        refs [path! none!]
        cont [any-block!]

        /local args
    ] [
        args: args? :f refs
        refs: either refs [to block! refs] [[ ]]
        remove-each ref refs [not find first :f to refinement! ref]
        enter-child ctx/niwashi [
            type: 'macro
            properties: [value: parse-code-block :f ctx/rules args: args refs: refs]
        ]
        cont: gather-args ctx length? args cont
        leave-child ctx/niwashi
        cont
    ]

+++Functions

    -parse-word-:
    parse-function: func [
        ctx [object!]
        f [any-function!]
        fref [any-function! path!]
        refs [path! none!]
        cont [any-block!]

        /local args
    ] [
        args: length? args? :f refs
        enter-child ctx/niwashi [
            type: 'function
            properties: [value: :fref]
        ]
        cont: gather-args ctx args cont
        leave-child ctx/niwashi
        cont
    ]

===Handling of special functions

    -specials-:
    :reduce func [ctx [object!] word [word!] rest [path! none!] cont [any-block!]] [
        ; Fixme
        cont
    ]
    :all func [ctx [object!] word [word!] rest [path! none!] cont [any-block!]] [
        ; Fixme
        cont
    ]

---|apply|

    -specials-:
    :apply func [ctx [object!] word [word!] rest [path! none!] cont [any-block!] /local w pos] [
        ; Fixme
        if rest [make error! "APPLY does not have refinements"]
        enter-child ctx/niwashi [type: 'apply]
        cont: gather-args ctx 1 cont
        ; Fixme
        unless block? cont/1 [make error! "Dynamic APPLY not yet implemented"]
        parse cont/1 [
            any [
                set w set-word! pos: (
                    enter-child ctx/niwashi [type: 'apply-arg properties: [name: to word! w]]
                    pos: parse-step ctx pos
                    leave-child ctx/niwashi
                ) :pos
                |
                set w word! (append-child ctx/niwashi [type: 'apply-ref properties: [name: w]])
            ]
        ]
        leave-child ctx/niwashi
        next cont
    ]

===Helper functions

    -helpers-:
    args?: func [f [any-function!] refs [path! none!] /local res r ra refs-rule] [
        refs-rule: if refs [
            [
                any [
                    set r refinement! copy ra any word! (
                        if all [find refs to word! r ra] [
                            append res ra
                        ]
                    )
                ]
            ]
        ]
        parse first :f [
            copy res any word! (unless res [res: copy [ ]])
            refs-rule
        ]
        res
    ]
    gather-args: func [ctx n cont] [ ; n > 0
        loop n [
            ; Fixme
            if tail? cont [make error! "Not enough arguments!"]
            cont: parse-step ctx cont
        ]
    ]
