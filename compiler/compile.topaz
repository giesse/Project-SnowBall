Topaz [
    Title: "Topaz compiler - COMPILE function"
    Author: "Gabriele Santilli"
    Copyright: 2011
    ; License: {
    ;     Permission is hereby granted, free of charge, to any person obtaining
    ;     a copy of this software and associated documentation files
    ;     (the "Software"), to deal in the Software without restriction, including
    ;     without limitation the rights to use, copy, modify, merge, publish,
    ;     distribute, sublicense, and/or sell copies of the Software, and to
    ;     permit persons to whom the Software is furnished to do so, subject
    ;     to the following conditions:

    ;     The above copyright notice and this permission notice shall be included
    ;     in all copies or substantial portions of the Software.

    ;     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    ;     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    ;     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    ;     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    ;     OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ;     ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    ;     OTHER DEALINGS IN THE SOFTWARE.
    ; }
]

compile: func [
    "Compile a FUNCTION! or ACTION! to a given target language"
    f [function! action!]
    language [word!] "Target language, eg. 'Javascript"

    return: code [string!] "The code in the target language"
] [
    phase1-to-language make-fundef :f language
]

make-fundef: action [
    "Create a function definition Phase 1 object"
    f

    return: phase1-fundef [object!]
] [
    function!: [
        arguments: phase0-parse-arguments context-of :f spec-of :f
        probe object phase1-fundef [
            arguments: arguments
            body: block-to-phase1 body-of :f
        ]
    ]
    action!: [
    ]
    native!: [
        ; TODO
        object none [
            type: 'native-fundef
            native: :f
        ]
    ]
    return!: [
        ; this may be a problem?
    ]
]

phase0-parse-arguments: func [
    "Phase 0: Parse function argument spec"
    context [context!] "The function's context"
    spec [block!] "The function's argument spec"

    return: arguments [block!] "Block of argument objects"
] [
    parse spec [
        collect [
            opt string!
            any [
                name: word! types: opt block! opt string!
                keep (
                    argument: object phase0-argument [
                        name: name
                        types: if types [make typeset! types]
                    ]
                    set-compiler-value bind name context argument
                )
            ]
            opt [
                literal options:
                some [
                    name: word! types: opt block! opt string!
                    keep (
                        argument: object phase0-argument [
                            name: name
                            types: if types [make typeset! types]
                            optional
                        ]
                        set-compiler-value bind name context argument
                    )
                    |
                    name: set-word! default-value: do-step types: opt block! opt string!
                    keep (
                        argument: object phase0-argument [
                            name: make word! name
                            default-value: default-value
                            types: if types [make typeset! types]
                            optional
                        ]
                        set-compiler-value bind name context argument
                    )
                ]
            ]
            [
                literal return:
                return-arguments: collect any [
                    name: word! types: opt block! opt string!
                    keep (object phase0-argument [
                        name: name
                        types: if types [make typeset! types]
                    ])
                ] (
                    set-compiler-value bind 'return context object phase0-return [
                        arguments: return-arguments
                    ]
                )
                |
                (set-compiler-value bind 'return context object phase0-return [])
            ]
        ]
    ]
]

phase1-fundef: object none [
    fundef?: yes
]

phase0-argument: object none [
]

phase0-return: object none [
]

block-to-phase1: func [
    "Convert a Topaz code block to a Phase 1 object (parsing pass)"
    block [block!]

    return: phase1-expr [object!]
] [
    phase1-expr: none
    expressions: make block! none
    while [not empty? block] [
        set this-context phase1-step block
        append expressions phase1-expr
    ]
    object phase1-expressions [
        expressions: expressions
    ]
]

phase1-step: func [
    "Convert a Topaz code block to a Phase 1 object (one step)"
    block [block!]

    return:
        phase1-expr [object!] "Phase 1 object representing the first expression in the block"
        block [block!] "Position of the next expression in the block"
] [
    value: first block
    phase1-expr: none
    set this-context value-to-phase1 value block
    while [op: operator? block] [
        block: next block
        if empty? block [
            cause-error [
                category: 'Compilation
                id: 'missing-argument
                message: "The operator is missing its second argument"
                stack: skip block -2
            ]
        ]
        expr2: value-to-phase1 first block block
        phase1-expr: object phase1-op [
            op: :op
            expr1: phase1-expr
            expr2: expr2/phase1-expr
        ]
        block: expr2/block
    ]
    return phase1-expr block
]

value-to-phase1: action [
    "Convert a specific value to a Phase 1 object"
    value
    block [block!] "Code block at the position of VALUE"

    return:
        phase1-expr [object!]
        block [block!] "Position of the next expression in the block"
] [
    word!: [
        word: value
        either expr: get-compiler-value word [
            either expr/fundef? [
                compile-function-call expr block
            ] [
                return expr next block
            ]
        ] [
            value: get/any word
            ; this will need to check for word being constant
            either any-function? :value [
                fundef: make-fundef :value
                set-compiler-value word fundef
                compile-function-call fundef block
            ] [
                phase1-expr: object phase1-get [
                    word: word
                ]
                return phase1-expr next block
            ]
        ]
    ]
    default: [
        phase1-expr: object phase1-value [
            value: value
        ]
        return phase1-expr next block
    ]
]

phase1-value: object none [
]

phase1-get: object none [
]

compile-function-call: func [
    "Compile a function call into a Phase 1 object"
    fundef [object!] "Phase 1 function definition object"
    block [block!] "Topaz code block (to collect arguments)"

    return:
        phase1-expr [object!]
        block [block!] "Position of the next expression in the block (after all arguments)"
] [
    ; TODO
    phase1-expr: object none [
        type: 'function-call
        function: fundef
    ]
    return phase1-expr next block
]

operator?: func [block] [
    if not empty? block [
        value: first block
        if word? :value [value: get/any value]
        if op? :value [
            :value
        ]
    ]
]

phase1-expressions: object none [
]

phase1-op: object none [
]

phase1-to-language: func [
    "Convert a Phase 1 object to the given target language"
    phase1-expr [object!]
    language [word!]

    return: code [string!] "The code in the target language"
] [
    phase2-expr: phase1-to-phase2 phase1-expr
    phase3-expr: phase2-to-phase3 phase2-expr language
    phase3-to-string phase3-expr
]

phase1-to-phase2: func [
    "Convert a Phase 1 object to a Phase 2 object (optimization pass)"
    phase1 [object!]

    return: phase2-expr [object!]
] [
]

phase2-to-phase3: func [
    "Convert a Phase 2 object to a Phase 3 object (compilation pass)"
    phase2-expr [object!]
    language [word!] "Target language"

    return: phase3-expr [object!]
] [
]

phase3-to-string: func [
    "Convert a Phase 3 object to code text"
    phase3-expr [object!]

    return: code [string!]
] [
    phase3-expr/to-string phase3-expr
]
