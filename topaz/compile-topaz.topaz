; Compile Topaz to topaz/topaz.js

load*: func [file] [load read file]

interpreter: load* "topaz/support.topaz"

app: func [code] [
    foreach 'value code [
        insert tail interpreter value
    ]
]

app-file: func [file] [app load* file]

app-file "topaz/actions.topaz"

; MAKE-TYPE macro
make-type: func [name actions] [
    struct: compose [
        type: datatype!
        name: (name)
    ]
    ; actions is an expression! here, hopefully ast-value containing a block!
    append struct actions/value
    make expression! compose [
        make-struct (struct)
    ]
]
macro: func [name spec body] [
    set name/value func spec/value body/value
    make expression! []
]

types-dir: "topaz/types/"
app-type: func [file] [app-file rejoin [types-dir file]]

; until dependency resolution is added...
foreach 'type [
    "datatype.topaz"
    "block.topaz"
    "paren.topaz"
    "path.topaz"
    "lit-path.topaz"
    "set-path.topaz"
    "word.topaz"
    "get-word.topaz"
    "lit-word.topaz"
    "set-word.topaz"
    "context.topaz"
    "function.topaz"
    "native.topaz"
    "op.topaz"
    "string.topaz"
    "char.topaz"
    "none.topaz"
    "logic.topaz"
    "number.topaz"
    "expression.topaz"
    "object.topaz"
    "throw.topaz"
    "return.topaz"
    "error.topaz"
    "typeset.topaz"
] [app-type type]

foreach 'file [
    "topaz/typesets.topaz"
    "topaz/load.topaz"
    "topaz/natives.topaz"
    "topaz/compiler.topaz"
] [app-file file]

app [
    sys: apply 'require ["sys"]
    fs: apply 'require ["fs"]
]
app reduce [
    make set-word! "init-code" read "topaz/init.topaz"
]
app [
    try [
        do load make string! init-code true
    ] 'e [
        print "FATAL: error during initialization^/"
        e: handle-js-error e
        if e/type/name <> "error!" [
            e: make error! make-struct [
                category: "Internal"
                id: "unhandled-throw"
                message: "Unhandled throw during initialization"
                args: e/type
            ]
        ]
        print form-error e
        print "^/"
        apply 'process/exit [1]
    ]

    handle-top-level-error: function [e] [] [
        e: handle-js-error e
        if e/type/name <> "error!" [
            e: make error! make-struct [
                category: "Script"
                id: "unhandled-throw"
                message: "Unhandled exception (THROW without CATCH)"
                args: e/type
            ]
        ]
        print form-error e
        print "^/"
    ]
    either 2 < length-of-array process/argv [
        try [
            do load read pick-array process/argv 2 true
        ] 'e [
            handle-top-level-error e
        ]
    ] [
        print "Topaz Interpreter - (C) 2011 Gabriele Santilli - MIT License^/"
        stdin: apply 'process/open-stdin []
        apply 'stdin/set-encoding ["utf8"]
        apply 'stdin/add-listener [
            "data"
            function [chunk] [res] [
                either chunk = "quit^/" [
                    apply 'stdin/destroy []
                ] [
                    try [
                        chunk: do load make string! chunk true
                        print "== " print mold-value chunk "== "
                        print "^/>> "
                    ] 'e [
                        handle-top-level-error e
                        print ">> "
                    ]
                ]
            ]
        ]
        print ">> "
    ]
]

parse-function-spec: func [spec] [
    ; does not support return: yet, nor default values
    parse spec [
        collect any [
            string!
            |
            block!
            |
            'options
            |
            keep word!
            |
            spec: here skip (cause make error! [
                category: 'Compilation
                id: 'invalid-spec
                message: "PARSE-FUNCTION-SPEC: Don't know how to handle this, yet"
                stack: spec
            ])
        ]
    ]
]
funcall-macro: func [name spec] [
    make function! reduce [
        spec
        compose [
            make expression! [
                apply (make lit-word! name) (parse-function-spec spec)
            ]
        ]
    ]
]

; define function call macros, make all set-words local, mask some interpreter functions
locals: parse interpreter [
    collect any [
        keep name: set-word! [
            'function keep ('funcall-macro) keep (make lit-word! name) keep block! block! block!
            |
            keep (none)
        ]
        |
        'macro name: lit-word! block! block! keep (make set-word! name) keep (none)
        |
        skip
    ]
]
locals: context append locals [context: func: object: none]
bind interpreter locals
bind interpreter compiler-keywords

write "topaz/topaz.js" compile interpreter
