; Compile Topaz to topaz/topaz.js

load*: func [file] [load read file]

interpreter: load* "topaz/support.topaz"

app: func [code] [
    foreach 'value code [
        insert tail interpreter value
    ]
]

app-file: func [file] [app load* file]

app-file "topaz/actions.topaz"

; MAKE-TYPE macro
make-type: func [name actions] [
    struct: compose [
        type: datatype!
        name: (name)
    ]
    ; actions is an expression! here, hopefully ast-value containing a block!
    append struct actions/value
    make expression! compose [
        make-struct (struct)
    ]
]
macro: func [name spec body] [
    set name/value func spec/value body/value
    make expression! []
]

types-dir: "topaz/types/"
app-type: func [file] [app-file rejoin [types-dir file]]

; until dependency resolution is added...
foreach 'type [
    "datatype.topaz"
    "block.topaz"
    "paren.topaz"
    "path.topaz"
    "lit-path.topaz"
    "set-path.topaz"
    "word.topaz"
    "get-word.topaz"
    "lit-word.topaz"
    "set-word.topaz"
    "context.topaz"
    "function.topaz"
    "native.topaz"
    "op.topaz"
    "string.topaz"
    "char.topaz"
    "none.topaz"
    "logic.topaz"
    "number.topaz"
    "expression.topaz"
    "object.topaz"
] [app-type type]

foreach 'file [
    "topaz/load.topaz"
    "topaz/natives.topaz"
    "topaz/compiler.topaz"
] [app-file file]

app [
    sys: apply 'require ["sys"]
    fs: apply 'require ["fs"]
]
app reduce [
    make set-word! "init-code" read "topaz/init.topaz"
]
app [
    try [
        do load make string! init-code true
    ] 'e [
        print "FATAL: error during initialization^/"
        print e + "^/"
        apply 'process/exit [1]
    ]

    either 2 < length-of-array process/argv [
        try [
            do load read pick-array process/argv 2 true
        ] 'e [
            print e + "^/"
        ]
    ] [
        print "Topaz Interpreter - (C) 2011 Gabriele Santilli - MIT License^/"
        stdin: apply 'process/open-stdin []
        apply 'stdin/set-encoding ["utf8"]
        apply 'stdin/add-listener [
            "data"
            function [chunk] [res] [
                either chunk = "quit^/" [
                    apply 'stdin/destroy []
                ] [
                    try [
                        chunk: do load make string! chunk true
                        print "== " print mold-value chunk "== "
                        print "^/>> "
                    ] 'e [
                        print e + "^/>> "
                    ]
                ]
            ]
        ]
        print ">> "
    ]
]

funcall-macro: func [name spec] [
    make function! reduce [
        spec
        compose [
            make expression! [
                apply (make lit-word! name) (copy spec)
            ]
        ]
    ]
]

; define function call macros, make all set-words local, mask some interpreter functions
locals: parse interpreter [
    collect any [
        keep name: set-word! [
            'function keep ('funcall-macro) keep (make lit-word! name) keep block! block! block!
            |
            keep (none)
        ]
        |
        'macro name: lit-word! block! block! keep (make set-word! name) keep (none)
        |
        skip
    ]
]
locals: context append locals [context: func: object: none]
bind interpreter locals
bind interpreter compiler-keywords

write "topaz/topaz.js" compile interpreter
