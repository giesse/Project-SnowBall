; Compile Topaz to topaz/topaz.js

load*: func [file] [load read file]

interpreter: load* "topaz/support.topaz"

app: func [code] [
    append interpreter code
]

app-file: func [file] [app load* file]

app-file "topaz/actions.topaz"

; MAKE-TYPE macro
make-internal-type: func [name actions] [
    struct: compose [
        type: datatype!
        name: (make string! name/value)
    ]
    ; actions is an expression! here, hopefully ast-value containing a block!
    append struct actions/value
    make expression! compose/only [
        (make set-word! name/value) make-struct (struct)
    ]
]
make-type: func [name actions] [
    make expression! compose/deep [
        make-internal-type name actions
        apply datatypes/push [(name/value)]
    ]
]
macro: func [name spec body] [
    set name/value func spec/value body/value
    make expression! []
]

types-dir: "topaz/types/"
app-type: func [file] [app-file rejoin [types-dir file]]

; until dependency resolution is added...
foreach 'type [
    "datatype.topaz"
    "block.topaz"
    "paren.topaz"
    "path.topaz"
    "lit-path.topaz"
    "set-path.topaz"
    "word.topaz"
    "get-word.topaz"
    "lit-word.topaz"
    "set-word.topaz"
    "context.topaz"
    "function.topaz"
    "native.topaz"
    "return.topaz"
    "op.topaz"
    "string.topaz"
    "char.topaz"
    "none.topaz"
    "logic.topaz"
    "number.topaz"
    "expression.topaz"
    "object.topaz"
    "throw.topaz"
    "return-value.topaz"
    "error.topaz"
    "typeset.topaz"
] [app-type type]

foreach 'file [
    "topaz/typesets.topaz"
    "topaz/load.topaz"
    "topaz/natives.topaz"
    "topaz/compiler.topaz"
] [app-file file]

app compose/deep [
    sys: apply require ["sys"]
    fs: apply require ["fs"]
    try [
        do load/all make string! (mold/only load* "topaz/init.topaz")
    ] 'e [
        print "FATAL: error during initialization"
        e: handle-js-error e
        if e/type/name <> "error!" [
            e: make error! make-struct [
                category: "Internal"
                id: "unhandled-throw"
                message: "Unhandled throw during initialization"
                args: e/type
            ]
        ]
        print form-error e
        apply process/exit [1]
    ]
]

app [
    handle-top-level-error: function [e] [] [
        e: handle-js-error e
        if e/type/name <> "error!" [
            e: make error! make-struct [
                category: "Script"
                id: "unhandled-throw"
                message: "Unhandled exception (THROW without CATCH)"
                args: e/type
            ]
        ]
        print form-error e
    ]
    either 2 < length-of-array process/argv [
        try [
            do load/all read process/argv/2
        ] 'e [
            handle-top-level-error e
        ]
    ] [
        print "Topaz Interpreter - (C) 2011 Gabriele Santilli - MIT License"
        stdin: apply process/open-stdin []
        apply stdin/set-encoding ["utf8"]
        apply stdin/add-listener [
            "data"
            function [chunk] [res] [
                try [
                    chunk: do load/all make string! chunk
                    prin "== " print mold/options [value: chunk indent: "== " limit: 100]
                    prin ">> "
                ] 'e [
                    handle-top-level-error e
                    prin ">> "
                ]
            ]
        ]
        prin ">> "
    ]
]

parse-function-spec: func [spec] [
    ; does not support return: yet, nor default values
    parse spec [
        collect any [
            string!
            |
            block!
            |
            'options
            |
            name: set-word! skip keep (make word! name)
            |
            keep word!
            |
            spec: here skip (cause make error! [
                category: 'Compilation
                id: 'invalid-spec
                message: "PARSE-FUNCTION-SPEC: Don't know how to handle this, yet"
                stack: spec
            ])
        ]
    ]
]
funcall-macro: func [name spec] [
    make function! reduce [
        spec
        compose/only/deep [
            make expression! [
                apply (make get-word! name) (parse-function-spec spec)
            ]
        ]
    ]
]

; define function call macros, make all set-words local, mask some interpreter functions
locals: parse interpreter [
    collect any [
        name: set-word! 'function
        keep (name) keep ('funcall-macro) keep (make lit-word! name)
        keep/only block! block! block!
        |
        'macro name: lit-word! block! block! keep (make set-word! name) keep (none)
        |
        skip
    ]
]
locals: context append locals [context: func: object: none]
bind interpreter locals
bind interpreter compiler-keywords

write "topaz/topaz.js" compile interpreter
