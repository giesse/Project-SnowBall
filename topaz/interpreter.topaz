; Topaz interpreter/compiler
;
; Copyright 2011 Gabriele Santilli
;
; Permission is hereby granted, free of charge, to any person obtaining
; a copy of this software and associated documentation files
; (the "Software"), to deal in the Software without restriction, including
; without limitation the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the Software, and to
; permit persons to whom the Software is furnished to do so, subject
; to the following conditions:
;
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
; OTHER DEALINGS IN THE SOFTWARE.

; I don't recommend looking at this file, your eyes will bleed.

print: function [text] [] [
    apply 'sys/print [text]
    text
]

js-probe: function [value] [] [
    print apply 'sys/inspect [value]
    print "^/"
    value
]

length-of-array: function [arr] [] [
    arr/length
]

insert-array: function [arr pos value] [] [
    apply 'arr/splice [pos 0 value]
]

error: function [type message where] [] [
    throw rejoin ["*** " type " error: " message "^/*** Where: " where]
]

datatype!: none

make-type: function [name] [] [
    make-struct [
        type: datatype!
        name: name
        make: none
        insert: none
        head: none
        pick: none
        length-of: none
        skip: none
        mold: none
        do: none
        get-path: none
        set-path: none
        bind: none
        tail: none
        topaz-make: none
        compile: none
    ]
]
datatype!: make-type "datatype!"
datatype!/type: datatype!
datatype!/mold: function [type indent] [] [
    type/name
]
datatype!/do: function [type block] [] [
    reduce [type skip block 1]
]
datatype!/bind: function [type context extend?] [] [
    type
]
datatype!/topaz-make: function [ignored] [] [
    error "Script" "Cannot make datatypes (yet)" ""
]
ast-value: function [value] [] [
    make-struct [
        node-type: "value/" + value/type/name
        value: value
        to-js: function [node context] [res] [
            switch node/value/type/name [
                "string!" [
                    res: apply 'JSON/stringify [node/value/string]
                ]
                "char!" [
                    res: apply 'JSON/stringify [node/value/string]
                ]
                "number!" [
                    res: apply 'node/value/number/to-string []
                ]
                "none!" [
                    res: "null"
                ]
                "logic!" [
                    either node/value/value [
                        res: "true"
                    ] [
                        res: "false"
                    ]
                ]
            ] [
                error "JS emitter" rejoin ["Cannot represent " node/value/type/name " values in JS"] ""
            ]
            either context = "return" [
                rejoin ["return " res ";"]
            ] [
                res
            ]
        ]
    ]
]
datatype!/compile: function [type block] [] [
    reduce [ast-value type skip block 1]
]

make: function [type arguments] [] [
    apply 'type/make [arguments]
]
insert: function [series value] [] [
    apply 'series/type/insert [series value]
]
head: function [series] [] [
    apply 'series/type/head [series]
]
pick: function [series pos] [] [
    apply 'series/type/pick [series pos]
]
length-of: function [series] [] [
    apply 'series/type/length-of [series]
]
empty?: function [series] [] [
    0 = length-of series
]
skip: function [series amount] [] [
    apply 'series/type/skip [series amount]
]
mold-value: function [value indent] [] [
    apply 'value/type/mold [value indent]
]
mold: function [value] [] [
    make string! mold-value value ""
]
operator?: function [block] [] []
do-op: function [op arg1 arg2] [] []
first: function [series] [] [
    pick series 0
]
do-step: function [value block] [result arg2 op] [
    try [
        set [result block] apply 'value/type/do [value block]
    ] 'e [
        throw rejoin [e "^/*** Where: " mold-value block ""]
    ]
    while [op: operator? block] [
        block: skip block 1
        if empty? block [error "Script" "Operator missing its second argument" mold-value skip block -2 ""]
        arg2: first block
        set [arg2 block] apply 'arg2/type/do [arg2 block]
        result: do-op op result arg2
    ]
    reduce [result block]
]
do: function [block] [] []
get: function [word] [] [
    if not word/context [
        error "Script" "Word has no context" word/word
    ]
    pick-array word/context/values word/offset
]
get-path: function [value selector] [] [
    switch selector/type/name [
        "paren!" [
            selector: do selector
        ]
        "get-word!" [
            selector: get selector
        ]
    ] []
    apply 'value/type/get-path [value selector]
]
set-path: function [value selector set-to] [] [
    switch selector/type/name [
        "paren!" [
            selector: do selector
        ]
        "get-word!" [
            selector: get selector
        ]
    ] []
    apply 'value/type/set-path [value selector set-to]
]
bind: function [words context extend?] [] [
    apply 'words/type/bind [words context extend?]
]
tail: function [series] [] [
    apply 'series/type/tail [series]
]

probe: function [value] [] [
    print apply 'value/type/mold [value ""]
    print "^/"
]

block!: make-type "block!"
block!/make: function [arguments] [] [
    make-struct [
        type: block!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
block!/topaz-make: function [ignored] [] [
    apply 'block!/make [none]
]
block!/insert: function [block value] [] [
    insert-array block/values block/pos value
    insert-array block/newlines block/pos false
    make-struct [
        type: block!
        values: block/values
        pos: block/pos + 1
        newlines: block/newlines
    ]
]
block!/head: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
block!/tail: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: length-of-array block/values
        newlines: block/newlines
    ]
]
block!/skip: function [block amount] [] [
    make-struct [
        type: block!
        values: block/values
        pos: block/pos + amount
        newlines: block/newlines
    ]
]
block!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
block!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
mold-step1: function [result values pos indent sep] [] [
    rejoin [result sep mold-value pick-array values pos indent]
]
mold-step2: function [result values newlines pos indent sep nlsep] [] [
    if pick-array newlines pos [
        sep: nlsep + indent
    ]
    mold-step1 result values pos indent sep
]
block!/mold: function [block indent] [result pos ind] [
    result: "["
    pos: block/pos
    ind: indent + "    "
    if pos < length-of-array block/values [
        result: mold-step2 result block/values block/newlines pos ind "" #"^/"
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step2 result block/values block/newlines pos ind #" " #"^/"
            pos: pos + 1
        ]
    ]
    if pick-array block/newlines pos [result: rejoin [result #"^/" indent]]
    result + #"]"
]
block!/do: function [block container] [] [
    reduce [block skip container 1]
]
bind-values: function [values pos context extend?] [] [
    while [pos < length-of-array values] [
        bind pick-array values pos context extend?
        pos: pos + 1
    ]
    none
]
block!/bind: function [words context extend?] [] [
    bind-values words/values words/pos context extend?
    words
]
block!/compile: function [block container] [] [
    reduce [ast-value block skip container 1]
]

paren!: make-type "paren!"
paren!/make: function [arguments] [] [
    make-struct [
        type: paren!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
paren!/topaz-make: function [ignored] [] [
    apply 'paren!/make [none]
]
paren!/insert: function [block value] [] [
    insert-array block/values block/pos value
    insert-array block/newlines block/pos false
    make-struct [
        type: paren!
        values: block/values
        pos: block/pos + 1
        newlines: block/newlines
    ]
]
paren!/head: function [block] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
paren!/tail: function [block] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: length-of-array block/values
        newlines: block/newlines
    ]
]
paren!/skip: function [block amount] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: block/pos + amount
        newlines: block/newlines
    ]
]
paren!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
paren!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
paren!/mold: function [block indent] [result pos ind] [
    result: "("
    pos: block/pos
    ind: indent + "    "
    if pos < length-of-array block/values [
        result: mold-step2 result block/values block/newlines pos ind "" #"^/"
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step2 result block/values block/newlines pos ind #" " #"^/"
            pos: pos + 1
        ]
    ]
    if pick-array block/newlines pos [result: rejoin [result #"^/" indent]]
    result + #")"
]
paren!/do: function [paren block] [] [
    reduce [do paren skip block 1]
]
paren!/bind: function [words context extend?] [] [
    bind-values words/values words/pos context extend?
    words
]
compile: function [block] [] []
to-js: function [node context] [] [
    apply 'node/to-js [node context]
]
ast-paren: function [expressions] [] [
    make-struct [
        node-type: "paren"
        expressions: expressions
        to-js: function [node context] [res] [
            to-js node/expressions context
        ]
    ]
]
paren!/compile: function [paren block] [] [
    reduce [ast-paren compile paren skip block 1]
]

path!: make-type "path!"
path!/make: function [arguments] [] [
    make-struct [
        type: path!
        values: make-array
        pos: 0
    ]
]
path!/topaz-make: function [ignored] [] [
    apply 'path!/make [none]
]
path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: path!
        values: block/values
        pos: block/pos + 1
    ]
]
path!/head: function [block] [] [
    make-struct [
        type: path!
        values: block/values
        pos: 0
    ]
]
path!/tail: function [block] [] [
    make-struct [
        type: path!
        values: block/values
        pos: length-of-array block/values
    ]
]
path!/skip: function [block amount] [] [
    make-struct [
        type: path!
        values: block/values
        pos: block/pos + amount
    ]
]
path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
path!/mold: function [block indent] [result pos] [
    result: ""
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result
]
path!/do: function [path block] [value] [
    if empty? path [error "Internal" "Empty PATH! value" mold-value block ""]
    value: get first path
    path: skip path 1
    while [not empty? path] [
        value: get-path value first path
        path: skip path 1
    ]
    either value/type/name = "function!" [
        apply 'value/type/do [value block]
    ] [
        reduce [value skip block 1]
    ]
]
path!/bind: function [path context extend?] [] [
    bind-values path/values 0 context extend?
    path
]
name-to-js: function [name] [] [
    switch name [
        "arguments" ["_arguments"]
        "do"        ["_do"]
        "json"      ["JSON"]
        "case"      ["_case"]
        "try"       ["_try"]
        "throw"     ["_throw"]
        "function"  ["_function"]
        "if"        ["_if"]
        "while"     ["_while"]
        "switch"    ["_switch"]
        "true"      ["_true"]
        "false"     ["_false"]
    ] [
        name: apply 'name/replace [
            regexp "-(.)" "g"
            function [match chr] [] [
                apply 'chr/to-upper-case []
            ]
        ]
        name: apply 'name/replace [
            regexp "^^(.)(.*)\?$" ""
            function [match chr rest] [] [
                rejoin ["is" apply 'chr/to-upper-case [] rest]
            ]
        ]
        apply 'name/replace ["!" "_type"]
    ]
]
to-js-common: function [js-text context] [] [
    switch context [
        "return" [
            rejoin ["return " js-text ";"]
        ]
        "statement" [
            js-text + ";"
        ]
    ] [
        js-text
    ]
]
ast-get: function [word] [] [
    make-struct [
        node-type: "get"
        word: word
        to-js: function [node context] [] [
            to-js-common name-to-js node/word/word context
        ]
    ]
]
ast-get-path: function [expr selector] [] [
    switch selector/type/name [
        "paren!" [
            selector: compile selector
        ]
        "get-word!" [
            selector: ast-get selector
        ]
    ] [
        selector: ast-value selector
    ]
    make-struct [
        node-type: "get-path"
        expr: expr
        selector: selector
        to-js: function [node context] [sel] [
            either node/selector/node-type = "value/word!" [
                sel: "." + name-to-js node/selector/value/word
            ] [
                sel: rejoin ["[" to-js node/selector "expression" "]"]
            ]
            to-js-common rejoin [to-js node/expr "expression" sel] context
        ]
    ]
]
path!/compile: function [path block] [expr] [
    if empty? path [error "Internal" "Empty PATH! value" mold-value block ""]
    expr: ast-get first path
    path: skip path 1
    while [not empty? path] [
        expr: ast-get-path expr first path
        path: skip path 1
    ]
    reduce [expr skip block 1]
]

set-path!: make-type "set-path!"
set-path!/make: function [arguments] [] [
    make-struct [
        type: set-path!
        values: make-array
        pos: 0
    ]
]
set-path!/topaz-make: function [ignored] [] [
    apply 'set-path!/make [none]
]
set-path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: set-path!
        values: block/values
        pos: block/pos + 1
    ]
]
set-path!/head: function [block] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: 0
    ]
]
set-path!/tail: function [block] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: length-of-array block/values
    ]
]
set-path!/skip: function [block amount] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: block/pos + amount
    ]
]
set-path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
set-path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
set-path!/mold: function [block indent] [result pos] [
    result: ""
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result + #":"
]
set-path!/do: function [path block] [value set-to] [
    if 2 > length-of path [error "Internal" "SET-PATH! with less than two values" mold-value block ""]
    value: get first path
    path: skip path 1
    while [1 < length-of path] [
        value: get-path value first path
        path: skip path 1
    ]
    block: skip block 1
    if empty? block [error "Script" "set-path needs a value" mold-value skip block -1 ""]
    set [set-to block] do-step first block block
    set-path value first path set-to
    reduce [set-to block]
]
set-path!/bind: function [path context extend?] [] [
    bind-values path/values 0 context extend?
    path
]
ast-set-path: function [expr selector set-to] [] [
    switch selector/type/name [
        "paren!" [
            selector: compile selector
        ]
        "get-word!" [
            selector: ast-get selector
        ]
    ] [
        selector: ast-value selector
    ]
    make-struct [
        node-type: "set-path"
        expr: expr
        selector: selector
        set-to: set-to
        to-js: function [node context] [res sel] [
            either node/selector/node-type = "value/word!" [
                sel: "." + name-to-js node/selector/value/word
            ] [
                sel: rejoin ["[" to-js node/selector "expression" "]"]
            ]
            res: rejoin [
                to-js node/expr "expression" sel "="
                to-js node/set-to "expression"
            ]
            switch context [
                "return" [
                    rejoin ["return (" res ");"]
                ]
                "statement" [
                    res + ";"
                ]
                "expression" [
                    rejoin ["(" res ")"]
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
            ] []
        ]
    ]
]
compile-step: function [block] [] []
set-path!/compile: function [path block] [expr set-to] [
    if 2 > length-of path [error "Internal" "SET-PATH! with less than two values" mold-value block ""]
    expr: ast-get first path
    path: skip path 1
    while [1 < length-of path] [
        expr: ast-get-path expr first path
        path: skip path 1
    ]
    block: skip block 1
    if empty? block [error "Compile" "set-path needs a value" mold-value skip block -1 ""]
    set [set-to block] compile-step block
    reduce [ast-set-path expr first path set-to block]
]

lit-path!: make-type "lit-path!"
lit-path!/make: function [arguments] [] [
    make-struct [
        type: lit-path!
        values: make-array
        pos: 0
    ]
]
lit-path!/topaz-make: function [ignored] [] [
    apply 'lit-path!/make [none]
]
lit-path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: lit-path!
        values: block/values
        pos: block/pos + 1
    ]
]
lit-path!/head: function [block] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: 0
    ]
]
lit-path!/tail: function [block] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: length-of-array block/values
    ]
]
lit-path!/skip: function [block amount] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: block/pos + amount
    ]
]
lit-path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
lit-path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
lit-path!/mold: function [block indent] [result pos] [
    result: "'"
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result
]
lit-path!/do: function [path block] [] [
    path: make-struct [
        type: path!
        values: path/values
        pos: path/pos
    ]
    reduce [path skip block 1]
]
lit-path!/bind: function [path context extend?] [] [
    bind-values path/values 0 context extend?
    path
]
lit-path!/compile: function [path block] [] [
    reduce [
        ast-value make-struct [
            type: path!
            values: path/values
            pos: path/pos
        ]
        skip block 1
    ]
]

string!: make-type "string!"
string!/make: function [arguments] [] [
    make-struct [
        type: string!
        string: arguments
        pos: 0
    ]
]
string!/topaz-make: function [ignored] [] [
    apply 'string!/make [""]
]
string!/length-of: function [string] [] [
    (length-of-array string/string) - string/pos
]
string!/pick: function [string pos] [] [
    pick-array string/string string/pos + pos
]
string!/skip: function [string amount] [] [
    make-struct [
        type: string!
        string: string/string
        pos: string/pos + amount
    ]
]
escape: function [str] [re result match i] [
    re: regexp "[\x00-\x19^^^"]" "mg"
    result: ""
    i: 0
    while [match: apply 're/exec [str]] [
        result: result + apply 'str/substr [i match/index - i]
        switch pick-array str match/index [
            #"^^" [
                result: result + "^^^^"
            ]
            #"^/" [
                result: result + "^^/"
            ]
            #"^"" [
                result: result + "^^^""
            ]
            #"^-" [
                result: result + "^^-"
            ]
            #"^!" [
                result: result + "^^!"
            ]
        ] [
            result: rejoin [result #"^^" to-char (apply 'str/char-code-at [match/index]) + 64]
        ]
        i: match/index + 1
    ]
    either i = 0 [
        str
    ] [
        result + apply 'str/substr [i]
    ]
]
string!/mold: function [string indent] [] [
    rejoin ["^"" escape string/string #"^""]
]
string!/do: function [string block] [] [
    reduce [string skip block 1]
]
string!/bind: function [value context extend?] [] [
    value
]
string!/compile: function [string block] [] [
    reduce [ast-value string skip block 1]
]

char!: make-type "char!"
char!/make: function [arguments] [] [
    make-struct [
        type: char!
        string: arguments
    ]
]
char!/topaz-make: function [number] [] [
    apply 'char!/make [to-char number/number]
]
char!/mold: function [char indent] [] [
    rejoin ["#^"" escape char/string "^""]
]
char!/do: function [char block] [] [
    reduce [char skip block 1]
]
char!/bind: function [value context extend?] [] [
    value
]
char!/compile: function [char block] [] [
    reduce [ast-value char skip block 1]
]

none!: make-type "none!"
none!/make: function [ignored] [] [
    make-struct [
        type: none!
    ]
]
none!/topaz-make: function [ignored] [] [
    apply 'none!/make [none]
]
none!/mold: function [value indent] [] [
    "none"
]
none!/do: function [value block] [] [
    reduce [value skip block 1]
]
none!/bind: function [value context extend?] [] [
    value
]
none!/compile: function [value block] [] [
    reduce [ast-value value skip block 1]
]

logic!: make-type "logic!"
logic!/make: function [value] [] [
    make-struct [
        type: logic!
        value: value
    ]
]
logic!/topaz-make: function [value] [] [
    switch value/type/name [
        "none!" [apply 'logic!/make [false]]
        "logic!" [apply 'logic!/make [value/value]]
    ] [
        apply 'logic!/make [true]
    ]
]
logic!/mold: function [value indent] [] [
    either value/value [
        "true"
    ] [
        "false"
    ]
]
logic!/do: function [value block] [] [
    reduce [value skip block 1]
]
logic!/bind: function [value context extend?] [] [
    value
]
logic!/compile: function [value block] [] [
    reduce [ast-value value skip block 1]
]

number!: make-type "number!"
number!/make: function [arguments] [] [
    make-struct [
        type: number!
        number: arguments
    ]
]
number!/topaz-make: function [ignored] [] [
    apply 'number!/make [0]
]
number!/mold: function [number indent] [] [
    apply 'number/number/to-string []
]
number!/do: function [number block] [] [
    reduce [number skip block 1]
]
number!/bind: function [value context extend?] [] [
    value
]
number!/compile: function [number block] [] [
    reduce [ast-value number skip block 1]
]

context!: make-type "context!"
context!/make: function [arguments] [] [
    make-struct [
        type: context!
        words: make-array
        values: make-array
        stack: make-array
    ]
]
collect-set-words: function [set-words block deep?] [] []
context!/topaz-make: function [code] [ctx] [
    ctx: make context! none
    bind collect-set-words make block! none code false ctx true
    do bind code ctx false
    ctx
]
context!/mold: function [context indent] [block i] [
    block: make block! none
    i: 0
    while [i < length-of-array context/words] [
        block: insert insert block make set-word! pick-array context/words i pick-array context/values i
        i: i + 1
    ]
    rejoin ["context " mold-value head block indent]
]
context!/do: function [context block] [] [
    reduce [context skip block 1]
]
context!/bind: function [value context extend?] [] [
    value
]
context!/compile: function [context block] [] [
    reduce [ast-value context skip block 1]
]
get-word-offset: function [context word] [] [
    apply 'context/words/index-of [word]
]
context!/get-path: function [context selector] [offset] [
    if any [selector/type/name <> "word!" 0 > offset: get-word-offset context selector/word] [
        error "Script" "Invalid path" mold-value selector ""
    ]
    pick-array context/values offset
]
context!/set-path: function [context selector set-to] [offset] [
    if any [selector/type/name <> "word!" 0 > offset: get-word-offset context selector/word] [
        error "Script" "Invalid path" mold-value selector ""
    ]
    poke-array context/values offset set-to
]

word!: make-type "word!"
word!/make: function [arguments] [] [
    make-struct [
        type: word!
        word: arguments
        context: none
        offset: none
    ]
]
word!/topaz-make: function [string] [] [
    apply 'word!/make [string/string]
]
word!/mold: function [word indent] [] [
    word/word
]
word!/do: function [word block] [] [
    word: get word
    case [
        not word [
            error "Script" "Word has no value" mold-value block ""
        ]
        any [word/type/name = "function!" word/type/name = "native!"] [
            apply 'word/type/do [word block]
        ]
        'else [
            reduce [word skip block 1]
        ]
    ]
]
add-word: function [context word value] [l] [
    l: length-of-array context/words
    poke-array context/words l word/word
    poke-array context/values l value
    l
]
bind-word: function [context word add?] [offset] [
    offset: get-word-offset context word/word
    if all [add? offset < 0] [
        offset: add-word context word none
    ]
    if offset >= 0 [
        word/context: context
        word/offset: offset
    ]
    word
]
word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
word!/compile: function [word block] [value] [
    value: get word
    either all [value any [value/type/name = "function!" value/type/name = "native!"]] [
        apply 'value/type/compile [value block]
    ] [
        reduce [ast-get word skip block 1]
    ]
]

set-word!: make-type "set-word!"
set-word!/make: function [arguments] [] [
    make-struct [
        type: set-word!
        word: arguments
        context: none
        offset: none
    ]
]
set-word!/topaz-make: function [string] [] [
    apply 'set-word!/make [string/string]
]
set-word!/mold: function [word indent] [] [
    word/word + #":"
]
set-word: function [word value] [] [
    if not word/context [
        error "Script" "Word has no context" word/word
    ]
    poke-array word/context/values word/offset value
    value
]
set-word!/do: function [word block] [set-to] [
    block: skip block 1
    if empty? block [error "Script" "set-word needs a value" mold-value skip block -1 ""]
    set [set-to block] do-step first block block
    set-word word set-to
    reduce [set-to block]
]
set-word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
ast-set: function [word set-to] [] [
    if set-to/node-type = "function-definition" [
        set-word bind-word compile-words word true set-to/func
        set-to/func/name: word
    ]
    make-struct [
        node-type: "set"
        word: word
        set-to: set-to
        to-js: function [node context] [res words name i] [
            either node/word/type/name = "block!" [
                if context <> "statement" [
                    error "Compile" "SET with multiple words can only be a statement" ""
                ]
                words: node/word
                res: rejoin [
                    "var _tmp=" to-js node/set-to "expression" ";"
                ]
                i: 0
                while [i < length-of words] [
                    name: pick words i
                    res: rejoin [
                        res
                        name-to-js name/word "=_tmp[" i "];"
                    ]
                    i: i + 1
                ]
                res
            ] [
                res: rejoin [
                    name-to-js node/word/word "="
                    to-js node/set-to "expression"
                ]
                switch context [
                    "return" [
                        rejoin ["return (" res ");"]
                    ]
                    "statement" [
                        res + ";"
                    ]
                    "expression" [
                        rejoin ["(" res ")"]
                    ]
                    "paren" [
                        rejoin ["(" res ")"]
                    ]
                ] []
            ]
        ]
    ]
]
set-word!/compile: function [word block] [set-to] [
    block: skip block 1
    if empty? block [error "Compile" "set-word needs a value" mold-value skip block -1 ""]
    set [set-to block] compile-step block
    reduce [ast-set word set-to block]
]

lit-word!: make-type "lit-word!"
lit-word!/make: function [arguments] [] [
    make-struct [
        type: lit-word!
        word: arguments
        context: none
        offset: none
    ]
]
lit-word!/topaz-make: function [string] [] [
    apply 'lit-word!/make [string/string]
]
lit-word!/mold: function [word indent] [] [
    "'" + word/word
]
lit-word!/do: function [word block] [] [
    word: make-struct [
        type: word!
        word: word/word
        context: word/context
        offset: word/offset
    ]
    reduce [word skip block 1]
]
lit-word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
lit-word!/compile: function [word block] [] [
    reduce [
        ast-value make-struct [
            type: word!
            word: word/word
            context: word/context
            offset: word/offset
        ]
        skip block 1
    ]
]

function!: make-type "function!"
append: function [block value] [] [
    head insert tail block value
]
collect-set-words: function [set-words block deep?] [value] [
    while [not empty? block] [
        value: first block
        switch value/type/name [
            "set-word!" [
                append set-words value
            ]
            "block!" [if deep? [collect-set-words set-words value true]]
            "paren!" [if deep? [collect-set-words set-words value true]]
        ] []
        block: skip block 1
    ]
    set-words
]
function!/make: function [arguments] [spec body context word] [
    set [spec body] arguments
    context: make context! none
    while [not empty? spec] [
        word: first spec
        if word/type/name <> "word!" [
            error "Script" "Invalid function spec" mold-value spec ""
        ]
        if 0 <= get-word-offset context word/word [
            error "Script" "Duplicate function argument name" mold-value spec ""
        ]
        add-word context word none
        spec: skip spec 1
    ]
    bind collect-set-words make block! none body true context true
    make-struct [
        type: function!
        context: context
        spec: head spec
        body: bind body context false
        name: none
    ]
]
function!/topaz-make: function [block] [] [
    apply 'function!/make [block/values]
]
function!/mold: function [func indent] [] [
    rejoin ["func " mold-value func/spec indent " " mold-value func/body indent]
]
clone-array: function [arr] [] [
    apply 'arr/concat []
]
push-context: function [context] [] [
    poke-array context/stack length-of-array context/stack context/values
    context/values: clone-array pick-array context/stack 0
]
pop-array: function [arr] [] [
    apply 'arr/pop []
]
pop-context: function [context] [] [
    context/values: pop-array context/stack
]
collect-arguments: function [n target block] [value orig-block i] [
    orig-block: block
    i: 0
    while [i < n] [
        if empty? block [
            error "Script" "Not enough arguments for function" mold-value skip orig-block -1 ""
        ]
        set [value block] do-step first block block
        poke-array target i value
        i: i + 1
    ]
    block
]
function!/do: function [func block] [result] [
    push-context func/context
    block: collect-arguments length-of func/spec func/context/values skip block 1
    result: do func/body
    pop-context func/context
    reduce [result block]
]
function!/bind: function [func context extend?] [] [
    func
]
ast-function-call: function [name args] [] [
    make-struct [
        node-type: "function-call"
        name: name
        args: args
        to-js: function [node context] [res i] [
            either node/name/type/name = "path!" [
                res: pick-array apply 'path!/compile [node/name make block! none] 0
                res: to-js res "expression"
            ] [
                res: name-to-js node/name/word
            ]
            res: res + "("
            if 0 < length-of-array node/args [
                res: res + to-js pick-array node/args 0 "expression"
                i: 1
                while [i < length-of-array node/args] [
                    res: rejoin [res "," to-js pick-array node/args i "expression"]
                    i: i + 1
                ]
            ]
            to-js-common res + ")" context
        ]
    ]
]
append-array: function [arr value] [] [
    apply 'arr/push [value]
]
compile-arguments: function [n block] [expr orig-block i args] [
    orig-block: block
    i: 0
    args: make-array
    while [i < n] [
        if empty? block [
            error "Compile" "Not enough arguments for function" mold-value skip orig-block -1 ""
        ]
        set [expr block] compile-step block
        append-array args expr
        i: i + 1
    ]
    reduce [args block]
]
function!/compile: function [func block] [args] [
    set [args block] compile-arguments length-of func/spec skip block 1
    reduce [
        ast-function-call func/name args
        block
    ]
]

native!: make-type "native!"
native!/make: function [arguments] [spec f c] [
    set [spec f c] arguments
    make-struct [
        type: native!
        args: make-array
        spec: spec
        func: f
        compile: c
    ]
]
native!/topaz-make: function [arguments] [spec name f c] [
    set [spec name] arguments/values
    name: name/word
    f: natives/(name-to-js name)
    c: native-compilers/(name-to-js name)
    if any [f/length <> length-of spec c/length <> length-of spec] [
        error "Script" rejoin [
            "The native code for " apply 'name/to-upper-case []
            " does not match the number of arguments in the spec"
        ] mold-value spec ""
    ]
    apply 'native!/make [reduce [spec f c]]
]
native!/mold: function [func indent] [] [
    "native " + mold-value func/spec indent
]
native!/do: function [func block] [] [
    block: collect-arguments length-of func/spec func/args skip block 1
    reduce [apply 'func/func/apply [none func/args] block]
]
native!/bind: function [func context extend?] [] [
    func
]
native!/compile: function [func block] [args] [
    set [args block] compile-arguments length-of func/spec skip block 1
    reduce [apply 'func/compile/apply [none args] block]
]

op!: make-type "op!"
op!/make: function [arguments] [] [
    if 2 <> length-of arguments/spec [
        error "Script" "Function must take exactly two arguments" ""
    ]
    make-struct [
        type: op!
        func: arguments
    ]
]
op!/topaz-make: function [func] [] [
    apply 'op!/make [func]
]
op!/mold: function [op indent] [] [
    "make op! " + mold-value op/func indent
]
op!/do: function [op block] [] [
    error "Script" "Infix use of OP!s is not supported" mold-value block ""
]
op!/bind: function [op context extend?] [] [
    op
]
op!/compile: function [op block] [] [
    error "Compile" "Infix use of OP!s is not supported" mold-value block ""
]
operator?: function [block] [value] [
    all [
        not empty? block
        value: first block
        value/type/name = "word!"
        value: get value
        value/type/name = "op!"
        value
    ]
]
do-op: function [op arg1 arg2] [result] [
    switch op/func/type/name [
        "function!" [
            push-context op/func/context
            poke-array op/func/context/values 0 arg1
            poke-array op/func/context/values 1 arg2
            result: do op/func/body
            pop-context op/func/context
            result
        ]
        "native!" [
            apply 'op/func/func [arg1 arg2]
        ]
    ] []
]

to-js-string: function [string] [] [
    apply 'string/string/substr [string/pos]
]

new-line: function [block newline?] [] [
    poke-array block/newlines block/pos newline?
]
insert-nl: function [block value newline?] [] [
    block: insert block value
    poke-array block/newlines block/pos - 1 newline?
    block
]

exec-re: function [str re] [] [
    apply 're/exec [str]
]
test-re: function [str re] [] [
    apply 're/test [str]
]

skip-spaces: function [text] [t newline?] [
    t: exec-re to-js-string text regexp "^^(\s|;.*\n)+" ""
    newline?: false
    if t [
        t: pick-array t 0
        newline?: test-re t regexp "\n" ""
        text: skip text length-of-array t
    ]
    reduce [text newline?]
]

empty-array?: function [array] [] [
    0 = length-of-array array
]

parse-number: function [text] [t] [
    t: exec-re to-js-string text regexp "^^[-+]?[0-9]+(\.[0-9]*)?([Ee][-+]?[0-9]{1,3})?" ""
    if all [t  0 < length-of-array t: pick-array t 0] [
        reduce [
            make number! apply 'parse-float [t]
            skip text length-of-array t
        ]
    ]
]

parse-word-chars: function [text] [t] [
    if t: exec-re to-js-string text regexp "^^[!&*+\-.<=>?A-Z^^_`a-z|~-ÿ]['!&*+\-.0-9<=>?A-Z^^_`a-z|~-ÿ]*" "" [
        pick-array t 0
    ]
]

parse-word: function [text] [w] [
    if w: parse-word-chars text [
        reduce [
            make word! w
            skip text length-of-array w
        ]
    ]
]

parse-set-word: function [text] [w] [
    if all [w: parse-word-chars text  #":" = pick text length-of-array w] [
        reduce [
            make set-word! w
            skip text 1 + length-of-array w
        ]
    ]
]

parse-lit-word: function [text] [w] [
    if all [#"'" = first text  w: parse-word-chars skip text 1] [
        reduce [
            make lit-word! w
            skip text 1 + length-of-array w
        ]
    ]
]

parse-values: function [values text] [] []

parse-block: function [text] [values] [
    if #"[" = first text [
        set [values text] parse-values make block! none skip text 1
        if #"]" <> first text [
            error "Syntax" "Missing ]" to-js-string text
        ]
        reduce [values skip text 1]
    ]
]

parse-paren: function [text] [values] [
    if #"(" = first text [
        set [values text] parse-values make paren! none skip text 1
        if #")" <> first text [
            error "Syntax" "Missing )" to-js-string text
        ]
        reduce [values skip text 1]
    ]
]

unescape: function [str] [result i j ch p] [
    result: ""
    i: 0
    while [0 <= j: apply 'str/index-of [#"^^" i]] [
        result: result + apply 'str/substr [i j - i]
        ch: pick-array str j + 1
        switch ch [
            #"/" [
                result: result + #"^/"
                i: j + 2
            ]
            #"-" [
                result: result + #"^-"
                i: j + 2
            ]
            #"^^" [
                result: result + #"^^"
                i: j + 2
            ]
            #"!" [
                result: result + #"^!"
                i: j + 2
            ]
        ] [
            case [
                all [ch >= #"@"  ch <= #"_"] [
                    result: result + to-char (apply 'ch/char-code-at [0]) - 64
                    i: j + 2
                ]
                all [
                    ch = #"("
                    p: exec-re apply 'str/substr [j + 1] regexp "^^\(([0-9A-Fa-f]+)\)" ""
                ] [
                    result: result + to-char apply 'parse-int [pick-array p 1 16]
                    i: j + 1 + length-of-array pick-array p 0
                ]
                'else [
                    result: result + ch
                    i: j + 2
                ]
            ]
        ]
    ]
    either i = 0 [
        str
    ] [
        result + apply 'str/substr [i]
    ]
]

parse-string: function [text] [t] [
    if #"^"" = pick text 0 [
        t: exec-re to-js-string text regexp "^^^"(([^^^"^^\f\n\r]*|\^^\([0-9A-Fa-f]+\)|\^^[^^\f\n\r])*)^"" ""
        either t [
            reduce [
                make string! unescape pick-array t 1
                skip text length-of-array pick-array t 0
            ]
        ] [
            error "Syntax" "Missing ^"" to-js-string text
        ]
    ]
]

parse-char: function [text] [ch] [
    ch: exec-re to-js-string text regexp "^^#^"(\^^?.|\^^\([0-9A-Fa-f]+\))^"" ""
    if ch [
        reduce [
            make char! unescape pick-array ch 1
            skip text length-of-array pick-array ch 0
        ]
    ]
]

parse-path-element: function [text] [] [
    any [
        parse-number   text
        parse-word     text
        parse-string   text
        parse-block    text
        parse-paren    text
        parse-char     text
    ]
]

parse-set-path: function [text] [path value] [
    if all [value: parse-word-chars text  #"/" = pick text length-of-array value] [
        path: make set-path! none
        path: insert path make word! value
        text: skip text length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        if all [not empty? text  #":" = first text] [
            reduce [head path skip text 1]
        ]
    ]
]

parse-path: function [text] [path value] [
    if all [value: parse-word-chars text  #"/" = pick text length-of-array value] [
        path: make path! none
        path: insert path make word! value
        text: skip text length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        reduce [head path text]
    ]
]

parse-lit-path: function [text] [path value] [
    if all [#"'" = first text  value: parse-word-chars skip text 1  #"/" = pick text 1 + length-of-array value] [
        path: make lit-path! none
        path: insert path make word! value
        text: skip text 1 + length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        reduce [head path text]
    ]
]

parse-value: function [text] [] [
    any [
        parse-number   text
        parse-set-word text
        parse-set-path text
        parse-path     text
        parse-lit-path text
        parse-word     text
        parse-lit-word text
        parse-string   text
        parse-block    text
        parse-paren    text
        parse-char     text
    ]
]

parse-values: function [values text] [value newline?] [
    set [text newline?] skip-spaces text
    while [all [not empty? text  #"]" <> first text  #")" <> first text]] [
        set [value text] parse-value text
        either value [
            values: insert-nl values value newline?
            set [text newline?] skip-spaces text
        ] [
            error "Syntax" "Parse error" to-js-string text
        ]
    ]
    new-line values newline?
    reduce [head values text]
]

system-words: make context! none
compile-words: make context! none

load: function [text all?] [values] [
    set [values text] parse-values make block! none text
    if not empty? text [
        error "Syntax" "Parse error" to-js-string text
    ]
    bind values system-words true
    either all [not all? 1 = length-of values] [
        first values
    ] [
        values
    ]
]

do: function [block] [result] [
    result: make none! none
    while [not empty? block] [
        set [result block] do-step first block block
    ]
    result
]

read: function [filename] [stat dir-contents i result] [
    stat: apply 'fs/stat-sync [filename]
    either apply 'stat/directory? [] [
        dir-contents: apply 'fs/readdir-sync [filename]
        result: make block! none
        i: 0
        while [i < length-of-array dir-contents] [
            result: insert result make string! pick-array dir-contents i
            i: i + 1
        ]
        head result
    ] [
        make string! apply 'fs/read-file-sync [filename "utf8"]
    ]
]

write: function [filename text] [] [
    apply 'fs/write-file-sync [filename text "utf8"]
    make none! none
]

compile-op: function [op expr1 expr2] [] [
    switch op/func/type/name [
        "function!" [
            ast-function-call op/func/name reduce [expr1 expr2]
        ]
        "native!" [
            apply 'op/func/compile [expr1 expr2]
         ]
    ] []
]

compile-step: function [block] [value expr op expr2] [
    value: first block
    try [
        set [expr block] apply 'value/type/compile [value block]
    ] 'e [
        throw rejoin [e "^/*** Compiling: " mold-value block ""]
    ]
    while [op: operator? block] [
        block: skip block 1
        if empty? block [error "Compile" "Operator missing its second argument" mold-value skip block -2 ""]
        value: first block
        set [expr2 block] apply 'value/type/compile [value block]
        expr: compile-op op expr expr2
    ]
    reduce [expr block]
]

ast-expressions: function [list] [] [
    make-struct [
        node-type: "expressions"
        list: list
        to-js: function [node context] [i res] [
            i: 0
            res: ""
            switch context [
                "statement" [
                    while [i < length-of-array node/list] [
                        res: res + to-js pick-array node/list i "statement"
                        i: i + 1
                    ]
                ]
                "expression" [
                    if 1 < length-of-array node/list [
                        error "Compile" "Multiple expressions in expression context (eg. paren! with more than one expression)" ""
                    ]
                    res: to-js pick-array node/list 0 "expression"
                ]
                "paren" [
                    if 1 < length-of-array node/list [
                        error "Compile" "Multiple expressions in expression context (eg. paren! with more than one expression)" ""
                    ]
                    res: to-js pick-array node/list 0 "paren"
                ]
                "return" [
                    while [i + 1 < length-of-array node/list] [
                        res: res + to-js pick-array node/list i "statement"
                        i: i + 1
                    ]
                    either i < length-of-array node/list [
                        res: res + to-js pick-array node/list i "return"
                    ] [
                        res: "return null;"
                    ]
                ]
            ] []
            res
        ]
    ]
]

compile: function [block] [result expr] [
    result: make-array
    while [not empty? block] [
        set [expr block] compile-step block
        append-array result expr
    ]
    ast-expressions result
]

set-words: function [words values] [i] [
    i: 0
    while [i < length-of words] [
        set-word pick words i pick values i
        i: i + 1
    ]
    values
]

values: make-struct [
    native!: native!
    make: make native! reduce [
        load make string! "type arguments" true
        function [type arguments] [] [
            apply 'type/topaz-make [arguments]
        ]
    ]
    datatype!: datatype!
    block!: block!
    paren!: paren!
    path!: path!
    set-path!: set-path!
    lit-path!: lit-path!
    string!: string!
    char!: char!
    number!: number!
    word!: word!
    set-word!: set-word!
    lit-word!: lit-word!
    function!: function!
    op!: op!
    none!: none!
    logic!: logic!
    context!: context!
    system-words: system-words
    compile-words: compile-words
]
true?: function [value] [] [
    switch value/type/name [
        "none!" [false]
        "logic!" [value/value]
    ] [
        true
    ]
]
natives: make-struct [
    foreach: function [words series body] [ctx res] [
        ctx: make context! none
        switch words/type/name [
            "word!" [
                words: append make block! none words
            ]
            "block!" []
        ] [
            error "Script" "FOREACH expected a word! or block! - not " + words/type/name ""
        ]
        bind words ctx true
        bind body ctx false
        res: make none! none
        while [not empty? series] [
            set-words words series
            res: do body
            series: skip series length-of words
        ]
        res
    ]
    set: function [word value] [] [
        switch word/type/name [
            "word!" [
                set-word word value
            ]
            "block!" [
                set-words word value
            ]
        ] [
            error "Script" "SET expected a word! or block! - not " + word/type/name ""
        ]
    ]
    reduce: function [block] [result value] [
        result: make block! none
        while [not empty? block] [
            set [value block] do-step first block block
            append result value
        ]
        result
    ]
    insert: function [series value] [] [insert series value]
    head: function [series] [] [head series]
    pick: function [series pos] [] [pick series pos/number]
    length-of: function [series] [] [make number! length-of series]
    skip: function [series amount] [] [skip series amount/number]
    mold: function [value] [] [mold value]
    do: function [block] [] [do block]
    get: function [word] [value] [
        value: get word
        if not value [
            error "Script" "Word has no value" mold-value word ""
        ]
        value
    ]
    bind: function [words context] [] [bind words context false]
    tail: function [series] [] [tail series]
    print: function [string] [] [
        print (to-js-string string) + "^/"
        string
    ]
    prin: function [string] [] [
        print to-js-string string
        string
    ]
    load: function [string] [] [load string false]
    read: function [filename] [] [read to-js-string filename]
    try: function [code word def] [res ctx] [
        try [
            res: do code
        ] 'e [
            ctx: make context! none
            bind-word ctx word true
            set-word word make string! e
            res: do bind def ctx false
        ]
        res
    ]
    add: function [val1 val2] [] [make number! val1/number + val2/number]
    subtract: function [val1 val2] [] [make number! val1/number - val2/number]
    equal?: function [val1 val2] [] [make logic! val1/number = val2/number]
    greater?: function [val1 val2] [] [make logic! val1/number > val2/number]
    lesser?: function [val1 val2] [] [make logic! val1/number < val2/number]
    not-equal?: function [val1 val2] [] [make logic! val1/number <> val2/number]
    greater-or-equal?: function [val1 val2] [] [make logic! val1/number >= val2/number]
    lesser-or-equal?: function [val1 val2] [] [make logic! val1/number <= val2/number]
    compile: function [block] [] [
        make string! to-js compile bind block compile-words true "statement"
    ]
    write: function [filename text] [] [
        write to-js-string filename to-js-string text
    ]
    throw: function [value] [] [
        throw value/string
    ]
    if: function [condition body] [] [
        either true? condition [
            do body
        ] [
            make none! none
        ]
    ]
    either: function [condition true-body false-body] [] [
        do either true? condition [true-body] [false-body]
    ]
    not: function [value] [] [make logic! not true? value]
    apply: function [func args] [] [error "Internal" "APPLY is not yet implemented" ""]
    while: function [condblock body] [res] [
        res: make none! none
        while [true? do condblock] [res: do body]
        res
    ]
    all: function [block] [res] [
        either empty? block [
            make logic! true
        ] [
            set [res block] do-step first block block
            while [all [true? res not empty? block]] [
                set [res block] do-step first block block
            ]
            res
        ]
    ]
    any: function [block] [res] [
        either empty? block [
            make none! none
        ] [
            set [res block] do-step first block block
            while [all [not true? res not empty? block]] [
                set [res block] do-step first block block
            ]
            res
        ]
    ]
    switch: function [value cases def] [] [error "Internal" "SWITCH is not yet implemented" ""]
    case: function [cases] [cond] [
        either empty? cases [
            make none! none
        ] [
            set [cond cases] do-step first cases cases
            while [not true? cond] [
                cases: skip cases 1
                set [cond cases] do-step first cases cases
            ]
            either empty? cases [
                make none! none
            ] [
                do first cases
            ]
        ]
    ]
    context-of: function [word] [] [word/context]
    rejoin: function [block] [result value] [
        result: ""
        while [not empty? block] [
            set [value block] do-step first block block
            value: either value/type/name = "string!" [
                value/string
            ] [
                mold-value value ""
            ]
            result: rejoin [result value]
        ]
        make string! result
    ]
    ; not really used in the interpreter
    function: function [spec locals body] [] []
    none: function [] [] []
    true: function [] [] []
    false: function [] [] []
    make-struct: function [spec] [] []
    make-array: function [] [] []
    poke-array: function [arr pos value] [] []
    pick-array: function [arr pos] [] []
    regexp: function [exp flags] [] []
    to-char: function [number] [] []
]

set-word load make string! "conjure" false make native! reduce [
    load make string! "name" true
    function [name] [] [
        values/(name-to-js name/word)
    ]
]

words-to-js: function [words] [res word] [
    res: ""
    if 0 < length-of words [
        word: first words
        res: name-to-js word/word
        words: skip words 1
        while [not empty? words] [
            word: first words
            res: rejoin [res "," name-to-js word/word]
            words: skip words 1
        ]
    ]
    res
]
ast-function-definition: function [spec locals body] [] [
    make-struct [
        node-type: "function-definition"
        spec: spec
        locals: locals
        body: body
        func: make function! reduce [spec make block! none]
        to-js: function [node context] [res] [
            res: rejoin ["function(" words-to-js node/spec "){"]
            if not empty? node/locals [
                res: rejoin [res "var " words-to-js node/locals ";"]
            ]
            res: rejoin [
                res
                to-js node/body "return"
                "}"
            ]
            switch context [
                "return" [
                    rejoin ["return " res ";"]
                ]
                "expression" [res]
                "paren" [
                    rejoin ["(" res ")"]
                ]
                "statement" [
                    error "Compile" "Function definition cannot be used as a statement" ""
                ]
            ] []
        ]
    ]
]
ast-throw: function [expr] [] [
    make-struct [
        node-type: "throw"
        expr: expr
        to-js: function [node context] [res] [
            res: rejoin ["throw " to-js node/expr "expression" ";"]
            switch context [
                "expression" [
                    error "Compile" "THROW cannot be used as an expression" ""
                ]
                "statement" [
                    res
                ]
                "paren" [
                    error "Compile" "THROW cannot be used as an expression" ""
                ]
                "return" [
                    res
                ]
            ] []
        ]
    ]
]
either-expr-to-js: function [node] [res] [
    res: rejoin [
        to-js node/condition "paren" " ? "
        to-js node/true-body "paren" " : "
    ]
    either node/false-body [
        res + to-js node/false-body "paren"
    ] [
        res + "null"
    ]
]
either-stmt-to-js: function [node context] [res] [
    res: rejoin [
        "if(" to-js node/condition "expression" "){"
        to-js node/true-body context
        "}"
    ]
    if node/false-body [
        either node/false-body/node-type = "either" [
            res: rejoin [
                res "else " to-js node/false-body context
            ]
        ] [
            res: rejoin [
                res "else{"
                to-js node/false-body context
                "}"
            ]
        ]
    ]
    res
]
ast-either: function [condition true-body false-body] [] [
    make-struct [
        node-type: "either"
        condition: condition
        true-body: true-body
        false-body: false-body
        to-js: function [node context] [] [
            switch context [
                "statement" [
                    either-stmt-to-js node "statement"
                ]
                "expression" [
                    either-expr-to-js node
                ]
                "paren" [
                    rejoin ["(" either-expr-to-js node ")"]
                ]
                "return" [
                    either-stmt-to-js node "return"
                ]
            ] []
        ]
    ]
]
ast-not: function [expr] [] [
    make-struct [
        node-type: "not"
        expr: expr
        to-js: function [node context] [] [
            to-js-common "!" + to-js node/expr "paren" context
        ]
    ]
]
ast-struct: function [spec] [] [
    make-struct [
        node-type: "struct"
        spec: spec
        to-js: function [node context] [res i name expr] [
            res: "{"
            if 0 < length-of-array node/spec [
                name: pick-array node/spec 0
                expr: pick-array node/spec 1
                res: rejoin [res name-to-js name ":" to-js expr "expression"]
                i: 2
                while [i < length-of-array node/spec] [
                    name: pick-array node/spec i
                    expr: pick-array node/spec i + 1
                    res: rejoin [res "," name-to-js name ":" to-js expr "expression"]
                    i: i + 2
                ]
            ]
            to-js-common res + "}" context
        ]
    ]
]
parse-struct-spec: function [block] [result name expr] [
    block: block/value
    result: make-array
    while [not empty? block] [
        name: first block
        if name/type/name <> "set-word!" [
            error "Compile" "Invalid struct spec, expected set-word!, not " + name/type/name mold-value block ""
        ]
        block: skip block 1
        if empty? block [
            error "Compile" "Struct field is missing its value" mold-value skip block -1 ""
        ]
        set [expr block] compile-step block
        append-array result name/word
        append-array result expr
    ]
    result
]
compile-reduce: function [block] [result expr] [
    result: make-array
    while [not empty? block] [
        set [expr block] compile-step block
        append-array result expr
    ]
    result
]
ast-reduce: function [exprs] [] [
    make-struct [
        node-type: "reduce"
        exprs: exprs
        to-js: function [node context] [res i expr] [
            res: "["
            if 0 < length-of-array node/exprs [
                expr: pick-array node/exprs 0
                res: rejoin [res to-js expr "expression"]
                i: 1
                while [i < length-of-array node/exprs] [
                    expr: pick-array node/exprs i
                    res: rejoin [res "," to-js expr "expression"]
                    i: i + 1
                ]
            ]
            to-js-common res + "]" context
        ]
    ]
]
ast-while: function [condition body] [] [
    make-struct [
        node-type: "while"
        condition: condition
        body: body
        to-js: function [node context] [] [
            either context = "statement" [
                rejoin [
                    "while(" to-js node/condition "expression" "){"
                    to-js node/body "statement"
                    "}"
                ]
            ] [
                error "Compile" "WHILE can only be used as a statement" ""
            ]
        ]
    ]
]
ast-poke: function [arr pos value] [] [
    make-struct [
        node-type: "poke"
        arr: arr
        pos: pos
        value: value
        to-js: function [node context] [res] [
            res: rejoin [
                to-js node/arr "paren" "["
                to-js node/pos "expression" "]="
                to-js node/value "expression"
            ]
            switch context [
                "return" [
                    rejoin ["return (" res ");"]
                ]
                "statement" [
                    res + ";"
                ]
                "expression" [
                    rejoin ["(" res ")"]
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
            ] []
        ]
    ]
]
ast-pick: function [arr pos] [] [
    make-struct [
        node-type: "pick"
        arr: arr
        pos: pos
        to-js: function [node context] [] [
            to-js-common rejoin [to-js node/arr "paren" "[" to-js node/pos "expression" "]"] context
        ]
    ]
]
ast-all: function [exprs] [] [
    make-struct [
        node-type: "all"
        exprs: exprs
        to-js: function [node context] [res i] [
            res: to-js pick-array node/exprs 0 "paren"
            i: 1
            while [i < length-of-array node/exprs] [
                res: rejoin [res "&&" to-js pick-array node/exprs i "paren"]
                i: i + 1
            ]
            switch context [
                "statement" [
                    error "Compile" "ALL cannot be used as a statement" ""
                ]
                "expression" [
                    res
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
                "return" [
                    rejoin ["return " res ";"]
                ]
            ] []
        ]
    ]
]
ast-any: function [exprs] [] [
    make-struct [
        node-type: "any"
        exprs: exprs
        to-js: function [node context] [res i] [
            res: to-js pick-array node/exprs 0 "paren"
            i: 1
            while [i < length-of-array node/exprs] [
                res: rejoin [res "||" to-js pick-array node/exprs i "paren"]
                i: i + 1
            ]
            switch context [
                "statement" [
                    error "Compile" "ANY cannot be used as a statement" ""
                ]
                "expression" [
                    res
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
                "return" [
                    rejoin ["return " res ";"]
                ]
            ] []
        ]
    ]
]
ast-regexp: function [exp flags] [] [
    make-struct [
        node-type: "regexp"
        exp: exp
        flags: flags
        to-js: function [node context] [] [
            to-js-common rejoin ["/" to-js-string node/exp "/" to-js-string node/flags] context
        ]
    ]
]
ast-switch: function [value cases def] [] [
    make-struct [
        node-type: "switch"
        value: value
        cases: cases
        def: def
        to-js: function [node context] [res i a-case] [
            switch context [
                "statement" [
                    res: rejoin ["switch(" to-js node/value "expression" "){"]
                    i: 0
                    while [i < length-of-array node/cases] [
                        a-case: pick-array node/cases i
                        res: rejoin [
                            res
                            "case " to-js a-case/value "expression" ":"
                            to-js a-case/expr "statement"
                            "break;"
                        ]
                        i: i + 1
                    ]
                    rejoin [
                        res
                        "default:"
                        to-js node/def "statement"
                        "}"
                    ]
                ]
                "expression" [
                    error "Compile" "SWITCH cannot be used as an expression" ""
                ]
                "paren" [
                    error "Compile" "SWITCH cannot be used as an expression" ""
                ]
                "return" [
                    res: rejoin ["switch(" to-js node/value "expression" "){"]
                    i: 0
                    while [i < length-of-array node/cases] [
                        a-case: pick-array node/cases i
                        res: rejoin [
                            res
                            "case " to-js a-case/value "expression" ":"
                            to-js a-case/expr "return"
                        ]
                        i: i + 1
                    ]
                    rejoin [
                        res
                        "default:"
                        to-js node/def "return"
                        "}"
                    ]
                ]
            ] []
        ]
    ]
]
compile-cases: function [cases] [] []
compile-cases: function [cases] [cond orig-cases] [
    either empty? cases [
        none
    ] [
        orig-cases: cases
        set [cond cases] compile-step cases
        if empty? cases [
            error "Compile" "Missing case block after condition" mold-value orig-cases ""
        ]
        either cond/node-type = "value/word!" [
            compile first cases
        ] [
            ast-either cond compile first cases compile-cases skip cases 1
        ]
    ]
]
ast-to-char: function [expr] [] [
    make-struct [
        node-type: "to-char"
        expr: expr
        to-js: function [node context] [] [
            to-js-common rejoin [
                "String.fromCharCode(" to-js node/expr "expression" ")"
            ] context
        ]
    ]
]
try-to-js: function [code name def context] [] [
    rejoin [
        "try{"
        to-js code context
        "}catch(" name-to-js name "){"
        to-js def context
        "}"
    ]
]
ast-try: function [code word def] [] [
    make-struct [
        node-type: "try"
        code: code
        word: word
        def: def
        to-js: function [node context] [] [
            switch context [
                "statement" [
                    try-to-js node/code node/word/word node/def "statement"
                ]
                "expression" [
                    error "Compile" "TRY cannot be used as an expression" ""
                ]
                "paren" [
                    error "Compile" "TRY cannot be used as an expression" ""
                ]
                "return" [
                    try-to-js node/code node/word/word node/def "return"
                ]
            ] []
        ]
    ]
]
ast-op: function [op val1 val2] [] [
    make-struct [
        node-type: "op/" + op
        op: op
        val1: val1
        val2: val2
        to-js: function [node context] [res] [
            res: rejoin [to-js node/val1 "paren" node/op to-js node/val2 "paren"]
            switch context [
                "statement" [
                    error "Compile" "Cannot use operator as a statement" ""
                ]
                "expression" [
                    res
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
                "return" [
                    rejoin ["return " res ";"]
                ]
            ] []
        ]
    ]
]
native-compilers: make-struct [
    foreach: function [word series body] [] []
    insert: function [series value] [] []
    head: function [series] [] []
    pick: function [series pos] [] []
    length-of: function [series] [] []
    skip: function [series amount] [] []
    mold: function [value] [] []
    do: function [block] [] []
    get: function [word] [] []
    bind: function [words context] [] []
    tail: function [series] [] []
    print: function [value] [] []
    prin: function [value] [] []
    load: function [string] [] []
    read: function [filename] [] []
    add: function [val1 val2] [] [ast-op "+" val1 val2]
    subtract: function [val1 val2] [] [ast-op "-" val1 val2]
    equal?: function [val1 val2] [] [ast-op "==" val1 val2]
    greater?: function [val1 val2] [] [ast-op ">" val1 val2]
    lesser?: function [val1 val2] [] [ast-op "<" val1 val2]
    not-equal?: function [val1 val2] [] [ast-op "!=" val1 val2]
    greater-or-equal?: function [val1 val2] [] [ast-op ">=" val1 val2]
    lesser-or-equal?: function [val1 val2] [] [ast-op "<=" val1 val2]
    compile: function [block] [] []
    write: function [filename text] [] []
    function: function [spec locals body] [] [
        ast-function-definition spec/value locals/value compile body/value
    ]
    none: function [] [] [ast-value make none! none]
    true: function [] [] [ast-value make logic! true]
    false: function [] [] [ast-value make logic! false]
    throw: function [value] [] [ast-throw value]
    set: function [word expr] [] [ast-set word/value expr]
    if: function [condition body] [] [
        ast-either condition compile body/value none
    ]
    either: function [condition true-body false-body] [] [
        ast-either condition compile true-body/value compile false-body/value
    ]
    not: function [value] [] [ast-not value]
    make-struct: function [spec] [] [ast-struct parse-struct-spec spec]
    apply: function [func-name args] [] [
        ast-function-call func-name/value compile-reduce args/value
    ]
    reduce: function [block] [] [ast-reduce compile-reduce block/value]
    while: function [condblock body] [condition] [
        condblock: condblock/value
        if empty? condblock [
            error "Compile" "WHILE's condition block cannot be empty" ""
        ]
        set [condition condblock] compile-step condblock
        if not empty? condblock [
            error "Compile" "WHILE's condition block can only have one expression" mold-value head condblock ""
        ]
        ast-while condition compile body/value
    ]
    make-array: function [] [] [ast-reduce make-array]
    poke-array: function [arr pos value] [] [ast-poke arr pos value]
    pick-array: function [arr pos] [] [ast-pick arr pos]
    all: function [block] [] [ast-all compile-reduce block/value]
    any: function [block] [] [ast-any compile-reduce block/value]
    regexp: function [exp flags] [] [ast-regexp exp/value flags/value]
    switch: function [value cases def] [expr compiled-cases] [
        cases: cases/value
        def: def/value
        compiled-cases: make-array
        while [not empty? cases] [
            set [expr cases] compile-step cases
            append-array compiled-cases make-struct [
                value: expr
                expr: compile first cases
            ]
            cases: skip cases 1
        ]
        ast-switch value compiled-cases compile def
    ]
    case: function [cases] [expr] [
        if empty? cases/value [
            error "Compile" "CASE needs at least one case" ""
        ]
        compile-cases cases/value
    ]
    to-char: function [number] [] [ast-to-char number]
    try: function [code word def] [] [
        ast-try compile code/value word/value compile def/value
    ]
    rejoin: function [block] [expr res] [
        block: block/value
        either empty? block [
            ast-value make string! ""
        ] [
            set [res block] compile-step block
            while [not empty? block] [
                set [expr block] compile-step block
                res: ast-op "+" res expr
            ]
            res
        ]
    ]
    context-of: function [word] [] []
]
