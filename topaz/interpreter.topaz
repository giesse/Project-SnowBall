
error: function [type message where] [] [
    throw join "*** " join type join " error: " join message join "^/*** Where: " where
]

datatype!: none

make-type: function [name] [] [
    make-struct [
        type: datatype!
        name: name
        make: none
        insert: none
        head: none
        pick: none
        length-of: none
        skip: none
        mold: none
        do: none
        get-path: none
        set-path: none
        bind: none
        tail: none
        topaz-make: none
    ]
]
datatype!: make-type "datatype!"
datatype!/type: datatype!
datatype!/mold: function [type indent] [] [
    type/name
]
datatype!/do: function [type block] [] [
    reduce [type skip block 1]
]
datatype!/bind: function [type context extend?] [] [
    type
]
datatype!/topaz-make: function [ignored] [] [
    error "Script" "Cannot make datatypes (yet)" ""
]

make: function [type arguments] [] [
    apply 'type/make [arguments]
]
insert: function [series value] [] [
    apply 'series/type/insert [series value]
]
head: function [series] [] [
    apply 'series/type/head [series]
]
pick: function [series pos] [] [
    apply 'series/type/pick [series pos]
]
length-of: function [series] [] [
    apply 'series/type/length-of [series]
]
empty?: function [series] [] [
    0 = length-of series
]
skip: function [series amount] [] [
    apply 'series/type/skip [series amount]
]
mold-value: function [value indent] [] [
    apply 'value/type/mold [value indent]
]
mold: function [value] [] [
    make string! mold-value value ""
]
do-step: function [value block] [] [
    apply 'value/type/do [value block]
]
do: function [block] [] []
get: function [word] [] [
    if not word/context [
        error "Script" "Word has no context" word/word
    ]
    pick-array word/context/values word/offset
]
get-path: function [value selector] [] [
    switch selector/type/name [
        "paren!" [
            selector: do selector
        ]
        "get-word!" [
            selector: get selector
        ]
    ] []
    apply 'value/type/get-path [value selector]
]
set-path: function [value selector set-to] [] [
    switch selector/type/name [
        "paren!" [
            selector: do selector
        ]
        "get-word!" [
            selector: get selector
        ]
    ] []
    apply 'value/type/set-path [value selector set-to]
]
bind: function [words context extend?] [] [
    apply 'words/type/bind [words context extend?]
]
tail: function [series] [] [
    apply 'series/type/tail [series]
]

probe: function [value] [] [
    print apply 'value/type/mold [value ""]
    print "^/"
]

block!: make-type "block!"
block!/make: function [arguments] [] [
    make-struct [
        type: block!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
block!/topaz-make: function [ignored] [] [
    apply 'block!/make [none]
]
block!/insert: function [block value] [] [
    insert-array block/values block/pos value
    insert-array block/newlines block/pos false
    make-struct [
        type: block!
        values: block/values
        pos: block/pos + 1
        newlines: block/newlines
    ]
]
block!/head: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
block!/tail: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: length-of-array block/values
        newlines: block/newlines
    ]
]
block!/skip: function [block amount] [] [
    make-struct [
        type: block!
        values: block/values
        pos: block/pos + amount
        newlines: block/newlines
    ]
]
block!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
block!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
mold-step1: function [result values pos indent sep] [] [
    join result join sep mold-value pick-array values pos indent
]
mold-step2: function [result values newlines pos indent sep nlsep] [] [
    if pick-array newlines pos [
        sep: join nlsep indent
    ]
    mold-step1 result values pos indent sep
]
block!/mold: function [block indent] [result pos ind] [
    result: "["
    pos: block/pos
    ind: join indent "    "
    if pos < length-of-array block/values [
        result: mold-step2 result block/values block/newlines pos ind "" #"^/"
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step2 result block/values block/newlines pos ind #" " #"^/"
            pos: pos + 1
        ]
    ]
    if pick-array block/newlines pos [result: join result join #"^/" indent]
    join result #"]"
]
block!/do: function [block container] [] [
    reduce [block skip container 1]
]
block!/bind: function [words context extend?] [pos] [
    pos: words/pos
    while [pos < length-of-array words/values] [
        bind pick-array words/values pos context extend?
        pos: pos + 1
    ]
    words
]

paren!: make-type "paren!"
paren!/make: function [arguments] [] [
    make-struct [
        type: paren!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
paren!/topaz-make: function [ignored] [] [
    apply 'paren!/make [none]
]
paren!/insert: function [block value] [] [
    insert-array block/values block/pos value
    insert-array block/newlines block/pos false
    make-struct [
        type: paren!
        values: block/values
        pos: block/pos + 1
        newlines: block/newlines
    ]
]
paren!/head: function [block] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
paren!/tail: function [block] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: length-of-array block/values
        newlines: block/newlines
    ]
]
paren!/skip: function [block amount] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: block/pos + amount
        newlines: block/newlines
    ]
]
paren!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
paren!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
paren!/mold: function [block indent] [result pos ind] [
    result: "("
    pos: block/pos
    ind: join indent "    "
    if pos < length-of-array block/values [
        result: mold-step2 result block/values block/newlines pos ind "" #"^/"
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step2 result block/values block/newlines pos ind #" " #"^/"
            pos: pos + 1
        ]
    ]
    if pick-array block/newlines pos [result: join result join #"^/" indent]
    join result #")"
]
paren!/do: function [paren block] [] [
    reduce [do paren skip block 1]
]
paren!/bind: function [words context extend?] [pos] [
    pos: words/pos
    while [pos < length-of-array words/values] [
        bind pick-array words/values pos context extend?
        pos: pos + 1
    ]
    words
]

path!: make-type "path!"
path!/make: function [arguments] [] [
    make-struct [
        type: path!
        values: make-array
        pos: 0
    ]
]
path!/topaz-make: function [ignored] [] [
    apply 'path!/make [none]
]
path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: path!
        values: block/values
        pos: block/pos + 1
    ]
]
path!/head: function [block] [] [
    make-struct [
        type: path!
        values: block/values
        pos: 0
    ]
]
path!/tail: function [block] [] [
    make-struct [
        type: path!
        values: block/values
        pos: length-of-array block/values
    ]
]
path!/skip: function [block amount] [] [
    make-struct [
        type: path!
        values: block/values
        pos: block/pos + amount
    ]
]
path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
path!/mold: function [block indent] [result pos] [
    result: ""
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result
]
first: function [series] [] [
    pick series 0
]
path!/do: function [path block] [value] [
    value: get first path
    path: skip path 1
    while [not empty? path] [
        value: get-path value first path
        path: skip path 1
    ]
    either value/type/name = "function!" [
        apply 'value/type/do [value block]
    ] [
        reduce [value skip block 1]
    ]
]
path!/bind: function [path context extend?] [] [
    bind pick-array path/values 0 context extend?
    path
]

set-path!: make-type "set-path!"
set-path!/make: function [arguments] [] [
    make-struct [
        type: set-path!
        values: make-array
        pos: 0
    ]
]
set-path!/topaz-make: function [ignored] [] [
    apply 'set-path!/make [none]
]
set-path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: set-path!
        values: block/values
        pos: block/pos + 1
    ]
]
set-path!/head: function [block] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: 0
    ]
]
set-path!/tail: function [block] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: length-of-array block/values
    ]
]
set-path!/skip: function [block amount] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: block/pos + amount
    ]
]
set-path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
set-path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
set-path!/mold: function [block indent] [result pos] [
    result: ""
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    join result #":"
]
set-path!/do: function [path block] [value set-to] [
    value: get first path
    path: skip path 1
    while [1 < length-of path] [
        value: get-path value first path
        path: skip path 1
    ]
    block: skip block 1
    if empty? block [error "Script" "set-path needs a value" mold-value skip block -1 ""]
    set [set-to block] do-step first block block
    set-path value first path set-to
    reduce [set-to block]
]
set-path!/bind: function [path context extend?] [] [
    bind pick-array path/values 0 context extend?
    path
]

lit-path!: make-type "lit-path!"
lit-path!/make: function [arguments] [] [
    make-struct [
        type: lit-path!
        values: make-array
        pos: 0
    ]
]
lit-path!/topaz-make: function [ignored] [] [
    apply 'lit-path!/make [none]
]
lit-path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: lit-path!
        values: block/values
        pos: block/pos + 1
    ]
]
lit-path!/head: function [block] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: 0
    ]
]
lit-path!/tail: function [block] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: length-of-array block/values
    ]
]
lit-path!/skip: function [block amount] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: block/pos + amount
    ]
]
lit-path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
lit-path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
lit-path!/mold: function [block indent] [result pos] [
    result: "'"
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result
]
lit-path!/do: function [path block] [] [
    path: make-struct [
        type: path!
        values: path/values
        pos: path/pos
    ]
    reduce [path skip block 1]
]
lit-path!/bind: function [path context extend?] [] [
    bind pick-array path/values 0 context extend?
    path
]

string!: make-type "string!"
string!/make: function [arguments] [] [
    make-struct [
        type: string!
        string: arguments
        pos: 0
    ]
]
string!/topaz-make: function [ignored] [] [
    apply 'string!/make [""]
]
string!/length-of: function [string] [] [
    (length-of-array string/string) - string/pos
]
string!/pick: function [string pos] [] [
    pick-array string/string string/pos + pos
]
string!/skip: function [string amount] [] [
    make-struct [
        type: string!
        string: string/string
        pos: string/pos + amount
    ]
]
escape: function [str] [re result match i] [
    re: regexp "[\x00-\x19^^^"]" "mg"
    result: ""
    i: 0
    while [match: apply 're/exec [str]] [
        result: join result apply 'str/substr [i match/index - i]
        switch pick-array str match/index [
            #"^^" [
                result: join result "^^^^"
            ]
            #"^/" [
                result: join result "^^/"
            ]
            #"^"" [
                result: join result "^^^""
            ]
            #"^-" [
                result: join result "^^-"
            ]
            #"^!" [
                result: join result "^^!"
            ]
        ] [
            result: join result join #"^^" to-char (apply 'str/char-code-at [match/index]) + 64
        ]
        i: match/index + 1
    ]
    either i = 0 [
        str
    ] [
        join result apply 'str/substr [i]
    ]
]
string!/mold: function [string indent] [] [
    join "^"" join escape string/string #"^""
]
string!/do: function [string block] [] [
    reduce [string skip block 1]
]
string!/bind: function [value context extend?] [] [
    value
]

char!: make-type "char!"
char!/make: function [arguments] [] [
    make-struct [
        type: char!
        string: arguments
    ]
]
char!/topaz-make: function [number] [] [
    apply 'char!/make [to-char number/number]
]
char!/mold: function [char indent] [] [
    join "#^"" join escape char/string "^""
]
char!/do: function [char block] [] [
    reduce [char skip block 1]
]
char!/bind: function [value context extend?] [] [
    value
]

number!: make-type "number!"
number!/make: function [arguments] [] [
    make-struct [
        type: number!
        number: arguments
    ]
]
number!/topaz-make: function [ignored] [] [
    apply 'number!/make [0]
]
number!/mold: function [number indent] [] [
    join "" number/number
]
number!/do: function [number block] [] [
    reduce [number skip block 1]
]
number!/bind: function [value context extend?] [] [
    value
]

word!: make-type "word!"
word!/make: function [arguments] [] [
    make-struct [
        type: word!
        word: arguments
        context: none
        offset: none
    ]
]
word!/topaz-make: function [string] [] [
    apply 'word!/make [string/string]
]
word!/mold: function [word indent] [] [
    word/word
]
word!/do: function [word block] [] [
    word: get word
    case [
        not word [
            error "Script" "Word has no value" mold-value block ""
        ]
        any [word/type/name = "function!" word/type/name = "native!"] [
            apply 'word/type/do [word block]
        ]
        'else [
            reduce [word skip block 1]
        ]
    ]
]
make-context: function [] [] [
    make-struct [
        words: make-array
        values: make-array
        stack: make-array
    ]
]
add-word: function [context word value] [l] [
    l: length-of-array context/words
    poke-array context/words l word/word
    poke-array context/values l value
    l
]
get-word-offset: function [context word] [] [
    apply 'context/words/index-of [word]
]
bind-word: function [context word add?] [offset] [
    offset: get-word-offset context word/word
    if all [add? offset < 0] [
        offset: add-word context word none
    ]
    if offset >= 0 [
        word/context: context
        word/offset: offset
    ]
    word
]
word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]

set-word!: make-type "set-word!"
set-word!/make: function [arguments] [] [
    make-struct [
        type: set-word!
        word: arguments
        context: none
        offset: none
    ]
]
set-word!/topaz-make: function [string] [] [
    apply 'set-word!/make [string/string]
]
set-word!/mold: function [word indent] [] [
    join word/word #":"
]
set-word: function [word value] [] [
    if not word/context [
        error "Script" "Word has no context" word/word
    ]
    poke-array word/context/values word/offset value
    value
]
set-word!/do: function [word block] [set-to] [
    block: skip block 1
    if empty? block [error "Script" "set-word needs a value" mold-value skip block -1 ""]
    set [set-to block] do-step first block block
    set-word word set-to
    reduce [set-to block]
]
set-word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]

lit-word!: make-type "lit-word!"
lit-word!/make: function [arguments] [] [
    make-struct [
        type: lit-word!
        word: arguments
        context: none
        offset: none
    ]
]
lit-word!/topaz-make: function [string] [] [
    apply 'lit-word!/make [string/string]
]
lit-word!/mold: function [word indent] [] [
    join "'" word/word
]
lit-word!/do: function [word block] [] [
    word: make-struct [
        type: word!
        word: word/word
        context: word/context
        offset: word/offset
    ]
    reduce [word skip block 1]
]
lit-word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]

function!: make-type "function!"
append: function [block value] [] [
    head insert tail block value
]
collect-set-words: function [set-words block] [value] [
    while [not empty? block] [
        value: first block
        switch value/type/name [
            "set-word!" [
                append set-words value
            ]
            "block!" [collect-set-words set-words value]
            "paren!" [collect-set-words set-words value]
        ] []
        block: skip block 1
    ]
    set-words
]
function!/make: function [arguments] [spec body context word] [
    set [spec body] arguments
    context: make-context
    while [not empty? spec] [
        word: first spec
        if word/type/name <> "word!" [
            error "Script" "Invalid function spec" mold-value spec ""
        ]
        if 0 <= get-word-offset context word/word [
            error "Script" "Duplicate function argument name" mold-value spec ""
        ]
        add-word context word none
        spec: skip spec 1
    ]
    bind collect-set-words make block! none body context true
    make-struct [
        type: function!
        context: context
        spec: head spec
        body: bind body context false
    ]
]
function!/topaz-make: function [block] [] [
    apply 'function!/make [block/values]
]
function!/mold: function [func indent] [] [
    join "func " join mold-value func/spec indent join " " mold-value func/body indent
]
clone-array: function [arr] [] [
    apply 'arr/concat []
]
push-context: function [context] [] [
    poke-array context/stack length-of-array context/stack context/values
    context/values: clone-array pick-array context/stack 0
]
pop-array: function [arr] [] [
    apply 'arr/pop []
]
pop-context: function [context] [] [
    context/values: pop-array context/stack
]
collect-arguments: function [n target block] [value orig-block i] [
    orig-block: skip block -1
    i: 0
    while [i < n] [
        if empty? block [
            error "Script" "Not enough arguments for function" mold-value orig-block ""
        ]
        set [value block] do-step first block block
        poke-array target i value
        i: i + 1
    ]
    block
]
function!/do: function [func block] [result] [
    push-context func/context
    block: collect-arguments length-of func/spec func/context/values skip block 1
    result: do func/body
    pop-context func/context
    reduce [result block]
]
function!/bind: function [func context extend?] [] [
    func
]

native!: make-type "native!"
native!/make: function [arguments] [spec f] [
    set [spec f] arguments
    make-struct [
        type: native!
        args: make-array
        spec: spec
        func: f
    ]
]
native!/topaz-make: function [ignored] [] [
    error "Script" "Cannot make natives (yet)" ""
]
native!/mold: function [func indent] [] [
    join "native " mold-value func/spec indent
]
native!/do: function [func block] [] [
    block: collect-arguments length-of func/spec func/args skip block 1
    reduce [apply 'func/func [func/args] block]
]
native!/bind: function [func context extend?] [] [
    func
]

to-js-string: function [string] [] [
    apply 'string/string/substr [string/pos]
]

new-line: function [block newline?] [] [
    poke-array block/newlines block/pos newline?
]
insert-nl: function [block value newline?] [] [
    block: insert block value
    poke-array block/newlines block/pos - 1 newline?
    block
]

exec-re: function [str re] [] [
    apply 're/exec [str]
]
test-re: function [str re] [] [
    apply 're/test [str]
]

skip-spaces: function [text] [t newline?] [
    t: exec-re to-js-string text regexp "^^(\s|;.*\n)+" ""
    newline?: false
    if t [
        t: pick-array t 0
        newline?: test-re t regexp "\n" ""
        text: skip text length-of-array t
    ]
    reduce [text newline?]
]

empty-array?: function [array] [] [
    0 = length-of-array array
]

parse-number: function [text] [t] [
    t: exec-re to-js-string text regexp "^^[-+]?[0-9]+(\.[0-9]*)?([Ee][-+]?[0-9]{1,3})?" ""
    if all [t  0 < length-of-array t: pick-array t 0] [
        reduce [
            make number! apply 'parse-float [t]
            skip text length-of-array t
        ]
    ]
]

parse-word-chars: function [text] [t] [
    if t: exec-re to-js-string text regexp "^^[!&*+\-.<=>?A-Z^^_`a-z|~-ÿ]['!&*+\-.0-9<=>?A-Z^^_`a-z|~-ÿ]*" "" [
        pick-array t 0
    ]
]

parse-word: function [text] [w] [
    if w: parse-word-chars text [
        reduce [
            make word! w
            skip text length-of-array w
        ]
    ]
]

parse-set-word: function [text] [w] [
    if all [w: parse-word-chars text  #":" = pick text length-of-array w] [
        reduce [
            make set-word! w
            skip text 1 + length-of-array w
        ]
    ]
]

parse-lit-word: function [text] [w] [
    if all [#"'" = first text  w: parse-word-chars skip text 1] [
        reduce [
            make lit-word! w
            skip text 1 + length-of-array w
        ]
    ]
]

parse-values: function [values text] [] []

parse-block: function [text] [values] [
    if #"[" = first text [
        set [values text] parse-values make block! none skip text 1
        if #"]" <> first text [
            error "Syntax" "Missing ]" to-js-string text
        ]
        reduce [values skip text 1]
    ]
]

parse-paren: function [text] [values] [
    if #"(" = first text [
        set [values text] parse-values make paren! none skip text 1
        if #")" <> first text [
            error "Syntax" "Missing )" to-js-string text
        ]
        reduce [values skip text 1]
    ]
]

unescape: function [str] [result i j ch p] [
    result: ""
    i: 0
    while [0 <= j: apply 'str/index-of [#"^^" i]] [
        result: join result apply 'str/substr [i j - i]
        ch: pick-array str j + 1
        switch ch [
            #"/" [
                result: join result #"^/"
                i: j + 2
            ]
            #"-" [
                result: join result #"^-"
                i: j + 2
            ]
            #"^^" [
                result: join result #"^^"
                i: j + 2
            ]
            #"!" [
                result: join result #"^!"
                i: j + 2
            ]
        ] [
            case [
                all [ch >= #"@"  ch <= #"_"] [
                    result: join result to-char (apply 'ch/char-code-at [0]) - 64
                    i: j + 2
                ]
                all [
                    ch = #"("
                    p: exec-re apply 'str/substr [j + 1] regexp "^^\(([0-9A-Fa-f]+)\)" ""
                ] [
                    result: join result to-char apply 'parse-int [pick-array p 1 16]
                    i: j + 1 + length-of-array pick-array p 0
                ]
                'else [
                    result: join result ch
                    i: j + 2
                ]
            ]
        ]
    ]
    either i = 0 [
        str
    ] [
        join result apply 'str/substr [i]
    ]
]

parse-string: function [text] [t] [
    if #"^"" = pick text 0 [
        t: exec-re to-js-string text regexp "^^^"(([^^^"^^\f\n\r]*|\^^\([0-9A-Fa-f]+\)|\^^[^^\f\n\r])*)^"" ""
        either t [
            reduce [
                make string! unescape pick-array t 1
                skip text length-of-array pick-array t 0
            ]
        ] [
            error "Syntax" "Missing ^"" to-js-string text
        ]
    ]
]

parse-char: function [text] [ch] [
    ch: exec-re to-js-string text regexp "^^#^"(\^^?.|\^^\([0-9A-Fa-f]+\))^"" ""
    if ch [
        reduce [
            make char! unescape pick-array ch 1
            skip text length-of-array pick-array ch 0
        ]
    ]
]

parse-path-element: function [text] [] [
    any [
        parse-number   text
        parse-word     text
        parse-string   text
        parse-block    text
        parse-paren    text
        parse-char     text
    ]
]

parse-set-path: function [text] [path value] [
    if all [value: parse-word-chars text  #"/" = pick text length-of-array value] [
        path: make set-path! none
        path: insert path make word! value
        text: skip text length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        if all [not empty? text  #":" = first text] [
            reduce [head path skip text 1]
        ]
    ]
]

parse-path: function [text] [path value] [
    if all [value: parse-word-chars text  #"/" = pick text length-of-array value] [
        path: make path! none
        path: insert path make word! value
        text: skip text length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        reduce [head path text]
    ]
]

parse-lit-path: function [text] [path value] [
    if all [#"'" = first text  value: parse-word-chars skip text 1  #"/" = pick text 1 + length-of-array value] [
        path: make lit-path! none
        path: insert path make word! value
        text: skip text 1 + length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        reduce [head path text]
    ]
]

parse-value: function [text] [] [
    any [
        parse-number   text
        parse-set-word text
        parse-set-path text
        parse-path     text
        parse-lit-path text
        parse-word     text
        parse-lit-word text
        parse-string   text
        parse-block    text
        parse-paren    text
        parse-char     text
    ]
]

parse-values: function [values text] [value newline?] [
    set [text newline?] skip-spaces text
    while [all [not empty? text  #"]" <> first text  #")" <> first text]] [
        set [value text] parse-value text
        either value [
            values: insert-nl values value newline?
            set [text newline?] skip-spaces text
        ] [
            error "Syntax" "Parse error" to-js-string text
        ]
    ]
    new-line values newline?
    reduce [head values text]
]

system-words: make-context

load: function [text] [values] [
    set [values text] parse-values make block! none text
    if not empty? text [
        error "Syntax" "Parse error" to-js-string text
    ]
    bind values system-words true
    either 1 = length-of values [
        first values
    ] [
        values
    ]
]

do: function [block] [result] [
    result: none
    while [not empty? block] [
        set [result block] do-step first block block
    ]
    result
]

read: function [filename] [] [
    make string! apply 'fs/read-file-sync [filename "utf8"]
]

run-test: function [block] [] [
    print ">> " probe block
    try [
        block: do block
        print "== " probe block
    ] 'err [
        print join err #"^/"
    ]
]

words: load make string! "datatype! make insert head pick length-of empty? skip mold do get bind tail probe block! paren! path! first set-path! lit-path! string! char! number! word! set-word! lit-word! function! append native! load reduce read run-test"

set-word pick words 0 datatype!
set-word pick words 1 make native! reduce [
    load make string! "type arguments"
    function [arguments] [type args] [
        set [type args] arguments
        apply 'type/topaz-make [args]
    ]
]
set-word pick words 2 make native! reduce [
    load make string! "series value"
    function [arguments] [series value] [
        set [series value] arguments
        insert series value
    ]
]
set-word pick words 3 make native! reduce [
    load make string! "[series]"
    function [arguments] [] [head pick-array arguments 0]
]
set-word pick words 4 make native! reduce [
    load make string! "series pos"
    function [arguments] [series pos] [
        set [series pos] arguments
        pick series pos/number
    ]
]
set-word pick words 5 make native! reduce [
    load make string! "[series]"
    function [arguments] [] [
        make number! length-of pick-array arguments 0
    ]
]
set-word pick words 6 make native! reduce [
    load make string! "[series]"
    function [arguments] [] [
        empty? pick-array arguments 0
    ]
]
set-word pick words 7 make native! reduce [
    load make string! "series amount"
    function [arguments] [series amount] [
        set [series amount] arguments
        skip series amount/number
    ]
]
set-word pick words 8 make native! reduce [
    load make string! "[value]"
    function [arguments] [] [
        mold pick-array arguments 0
    ]
]
set-word pick words 9 make native! reduce [
    load make string! "[block]"
    function [arguments] [] [
        do pick-array arguments 0
    ]
]
set-word pick words 10 make native! reduce [
    load make string! "[word]"
    function [arguments] [word value] [
        value: get word: pick-array arguments 0
        if not value [
            error "Script" "Word has no value" mold-value word ""
        ]
        value
    ]
]
set-word pick words 11 make native! reduce [
    load make string! "[words context]"
    function [arguments] [words context extend?] [
        set [words context] arguments
        bind words context/context false
    ]
]
set-word pick words 12 make native! reduce [
    load make string! "[series]"
    function [arguments] [] [
        tail pick-array arguments 0
    ]
]
set-word pick words 13 make native! reduce [
    load make string! "[value]"
    function [arguments] [value] [
        probe value: pick-array arguments 0
        value
    ]
]
set-word pick words 14 block!
set-word pick words 15 paren!
set-word pick words 16 path!
set-word pick words 17 make native! reduce [
    load make string! "[series]"
    function [arguments] [] [
        first pick-array arguments 0
    ]
]
set-word pick words 18 set-path!
set-word pick words 19 lit-path!
set-word pick words 20 string!
set-word pick words 21 char!
set-word pick words 22 number!
set-word pick words 23 word!
set-word pick words 24 set-word!
set-word pick words 25 lit-word!
set-word pick words 26 function!
set-word pick words 27 make native! reduce [
    load make string! "series value"
    function [arguments] [series value] [
        set [series value] arguments
        append series value
    ]
]
set-word pick words 28 native!
set-word pick words 29 make native! reduce [
    load make string! "[text]"
    function [arguments] [] [
        load pick-array arguments 0
    ]
]
set-word pick words 30 make native! reduce [
    load make string! "[block]"
    function [arguments] [block result value] [
        block: pick-array arguments 0
        result: make block! none
        while [not empty? block] [
            set [value block] do-step first block block
            append result value
        ]
        result
    ]
]
set-word pick words 31 make native! reduce [
    load make string! "[filename]"
    function [arguments] [] [
        read to-js-string pick-array arguments 0
    ]
]
set-word pick words 32 make native! reduce [
    load make string! "[block]"
    function [arguments] [] [
        run-test pick-array arguments 0
    ]
]


sys: apply 'require ["sys"]
fs: apply 'require ["fs"]

do load read "topaz/init.topaz"
do load read "topaz/tests.topaz"
