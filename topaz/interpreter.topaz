; Topaz interpreter/compiler
;
; Copyright 2011 Gabriele Santilli
;
; Permission is hereby granted, free of charge, to any person obtaining
; a copy of this software and associated documentation files
; (the "Software"), to deal in the Software without restriction, including
; without limitation the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the Software, and to
; permit persons to whom the Software is furnished to do so, subject
; to the following conditions:
;
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
; OTHER DEALINGS IN THE SOFTWARE.

; I don't recommend looking at this file, your eyes will bleed.

print: function [text] [] [
    apply 'sys/print [text]
    text
]

js-probe: function [value] [] [
    print apply 'sys/inspect [value]
    print "^/"
    value
]

length-of-array: function [arr] [] [
    arr/length
]

insert-array: function [arr pos value] [] [
    apply 'arr/splice [pos 0 value]
]

error: function [type message where] [] [
    throw rejoin ["*** " type " error: " message "^/*** Where: " where]
]

datatype!: none

make-type: function [name] [] [
    make-struct [
        type: datatype!
        name: name
        make: none
        insert: none
        head: none
        pick: none
        length-of: none
        skip: none
        mold: none
        do: none
        get-path: none
        set-path: none
        bind: none
        tail: none
        topaz-make: none
        compile: none
    ]
]
datatype!: make-type "datatype!"
datatype!/type: datatype!
datatype!/mold: function [type indent] [] [
    type/name
]
datatype!/do: function [type block] [] [
    reduce [type skip block 1]
]
datatype!/bind: function [type context extend?] [] [
    type
]
datatype!/topaz-make: function [ignored] [] [
    error "Script" "Cannot make datatypes (yet)" ""
]
ast-value: function [value] [] [
    make-struct [
        node-type: "value/" + value/type/name
        value: value
        to-js: function [node context] [res] [
            switch node/value/type/name [
                "string!" [
                    res: apply 'JSON/stringify [node/value/string]
                ]
                "char!" [
                    res: apply 'JSON/stringify [node/value/string]
                ]
                "number!" [
                    res: apply 'node/value/number/to-string []
                ]
                "none!" [
                    res: "null"
                ]
                "logic!" [
                    either node/value/value [
                        res: "true"
                    ] [
                        res: "false"
                    ]
                ]
            ] [
                error "JS emitter" rejoin ["Cannot represent " node/value/type/name " values in JS"] ""
            ]
            either context = "return" [
                rejoin ["return " res ";"]
            ] [
                res
            ]
        ]
    ]
]
datatype!/compile: function [type block] [] [
    reduce [ast-value type skip block 1]
]

make: function [type arguments] [] [
    apply 'type/make [arguments]
]
insert: function [series value] [] [
    apply 'series/type/insert [series value]
]
head: function [series] [] [
    apply 'series/type/head [series]
]
pick: function [series pos] [] [
    apply 'series/type/pick [series pos]
]
length-of: function [series] [] [
    apply 'series/type/length-of [series]
]
empty?: function [series] [] [
    0 = length-of series
]
skip: function [series amount] [] [
    apply 'series/type/skip [series amount]
]
mold-value: function [value indent] [] [
    apply 'value/type/mold [value indent]
]
mold: function [value] [] [
    make string! mold-value value ""
]
operator?: function [block] [] []
do-op: function [op arg1 arg2] [] []
first: function [series] [] [
    pick series 0
]
do-step: function [value block] [result arg2 op] [
    set [result block] apply 'value/type/do [value block]
    while [op: operator? block] [
        block: skip block 1
        if empty? block [error "Script" "Operator missing its second argument" mold-value skip block -2 ""]
        arg2: first block
        set [arg2 block] apply 'arg2/type/do [arg2 block]
        result: do-op op result arg2
    ]
    reduce [result block]
]
do: function [block] [] []
get: function [word] [] [
    if not word/context [
        error "Script" "Word has no context" word/word
    ]
    pick-array word/context/values word/offset
]
get-path: function [value selector] [] [
    switch selector/type/name [
        "paren!" [
            selector: do selector
        ]
        "get-word!" [
            selector: get selector
        ]
    ] []
    apply 'value/type/get-path [value selector]
]
set-path: function [value selector set-to] [] [
    switch selector/type/name [
        "paren!" [
            selector: do selector
        ]
        "get-word!" [
            selector: get selector
        ]
    ] []
    apply 'value/type/set-path [value selector set-to]
]
bind: function [words context extend?] [] [
    apply 'words/type/bind [words context extend?]
]
tail: function [series] [] [
    apply 'series/type/tail [series]
]

probe: function [value] [] [
    print apply 'value/type/mold [value ""]
    print "^/"
]

block!: make-type "block!"
block!/make: function [arguments] [] [
    make-struct [
        type: block!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
block!/topaz-make: function [ignored] [] [
    apply 'block!/make [none]
]
block!/insert: function [block value] [] [
    insert-array block/values block/pos value
    insert-array block/newlines block/pos false
    make-struct [
        type: block!
        values: block/values
        pos: block/pos + 1
        newlines: block/newlines
    ]
]
block!/head: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
block!/tail: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: length-of-array block/values
        newlines: block/newlines
    ]
]
block!/skip: function [block amount] [] [
    make-struct [
        type: block!
        values: block/values
        pos: block/pos + amount
        newlines: block/newlines
    ]
]
block!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
block!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
mold-step1: function [result values pos indent sep] [] [
    rejoin [result sep mold-value pick-array values pos indent]
]
mold-step2: function [result values newlines pos indent sep nlsep] [] [
    if pick-array newlines pos [
        sep: nlsep + indent
    ]
    mold-step1 result values pos indent sep
]
block!/mold: function [block indent] [result pos ind] [
    result: "["
    pos: block/pos
    ind: indent + "    "
    if pos < length-of-array block/values [
        result: mold-step2 result block/values block/newlines pos ind "" #"^/"
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step2 result block/values block/newlines pos ind #" " #"^/"
            pos: pos + 1
        ]
    ]
    if pick-array block/newlines pos [result: rejoin [result #"^/" indent]]
    result + #"]"
]
block!/do: function [block container] [] [
    reduce [block skip container 1]
]
bind-values: function [values pos context extend?] [] [
    while [pos < length-of-array values] [
        bind pick-array values pos context extend?
        pos: pos + 1
    ]
    none
]
block!/bind: function [words context extend?] [] [
    bind-values words/values words/pos context extend?
    words
]
block!/compile: function [block container] [] [
    reduce [ast-value block skip container 1]
]

paren!: make-type "paren!"
paren!/make: function [arguments] [] [
    make-struct [
        type: paren!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
paren!/topaz-make: function [ignored] [] [
    apply 'paren!/make [none]
]
paren!/insert: function [block value] [] [
    insert-array block/values block/pos value
    insert-array block/newlines block/pos false
    make-struct [
        type: paren!
        values: block/values
        pos: block/pos + 1
        newlines: block/newlines
    ]
]
paren!/head: function [block] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
paren!/tail: function [block] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: length-of-array block/values
        newlines: block/newlines
    ]
]
paren!/skip: function [block amount] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: block/pos + amount
        newlines: block/newlines
    ]
]
paren!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
paren!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
paren!/mold: function [block indent] [result pos ind] [
    result: "("
    pos: block/pos
    ind: indent + "    "
    if pos < length-of-array block/values [
        result: mold-step2 result block/values block/newlines pos ind "" #"^/"
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step2 result block/values block/newlines pos ind #" " #"^/"
            pos: pos + 1
        ]
    ]
    if pick-array block/newlines pos [result: rejoin [result #"^/" indent]]
    result + #")"
]
paren!/do: function [paren block] [] [
    reduce [do paren skip block 1]
]
paren!/bind: function [words context extend?] [] [
    bind-values words/values words/pos context extend?
    words
]
compile: function [block] [] []
to-js: function [node context] [] [
    apply 'node/to-js [node context]
]
ast-paren: function [expressions] [] [
    make-struct [
        node-type: "paren"
        expressions: expressions
        to-js: function [node context] [res] [
            to-js node/expressions context
        ]
    ]
]
paren!/compile: function [paren block] [] [
    reduce [ast-paren compile paren skip block 1]
]

path!: make-type "path!"
path!/make: function [arguments] [] [
    make-struct [
        type: path!
        values: make-array
        pos: 0
    ]
]
path!/topaz-make: function [ignored] [] [
    apply 'path!/make [none]
]
path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: path!
        values: block/values
        pos: block/pos + 1
    ]
]
path!/head: function [block] [] [
    make-struct [
        type: path!
        values: block/values
        pos: 0
    ]
]
path!/tail: function [block] [] [
    make-struct [
        type: path!
        values: block/values
        pos: length-of-array block/values
    ]
]
path!/skip: function [block amount] [] [
    make-struct [
        type: path!
        values: block/values
        pos: block/pos + amount
    ]
]
path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
path!/mold: function [block indent] [result pos] [
    result: ""
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result
]
path!/do: function [path block] [value] [
    if empty? path [error "Internal" "Empty PATH! value" mold-value block ""]
    value: get first path
    path: skip path 1
    while [not empty? path] [
        value: get-path value first path
        path: skip path 1
    ]
    either value/type/name = "function!" [
        apply 'value/type/do [value block]
    ] [
        reduce [value skip block 1]
    ]
]
path!/bind: function [path context extend?] [] [
    bind-values path/values 0 context extend?
    path
]
name-to-js: function [name] [] [
    switch name [
        "arguments" ["_arguments"]
        "do"        ["_do"]
        "json"      ["JSON"]
        "case"      ["_case"]
    ] [
        name: apply 'name/replace [
            regexp "-(.)" "g"
            function [match chr] [] [
                apply 'chr/to-upper-case []
            ]
        ]
        name: apply 'name/replace [
            regexp "^^(.)(.*)\?$" ""
            function [match chr rest] [] [
                rejoin ["is" apply 'chr/to-upper-case [] rest]
            ]
        ]
        apply 'name/replace ["!" "_type"]
    ]
]
to-js-common: function [js-text context] [] [
    switch context [
        "return" [
            rejoin ["return " js-text ";"]
        ]
        "statement" [
            js-text + ";"
        ]
    ] [
        js-text
    ]
]
ast-get: function [word] [] [
    make-struct [
        node-type: "get"
        word: word
        to-js: function [node context] [] [
            to-js-common name-to-js node/word/word context
        ]
    ]
]
ast-get-path: function [expr selector] [] [
    switch selector/type/name [
        "paren!" [
            selector: compile selector
        ]
        "get-word!" [
            selector: ast-get selector
        ]
    ] [
        selector: ast-value selector
    ]
    make-struct [
        node-type: "get-path"
        expr: expr
        selector: selector
        to-js: function [node context] [sel] [
            either node/selector/node-type = "value/word!" [
                sel: "." + name-to-js node/selector/value/word
            ] [
                sel: rejoin ["[" to-js node/selector "expression" "]"]
            ]
            to-js-common rejoin [to-js node/expr "expression" sel] context
        ]
    ]
]
path!/compile: function [path block] [expr] [
    if empty? path [error "Internal" "Empty PATH! value" mold-value block ""]
    expr: ast-get first path
    path: skip path 1
    while [not empty? path] [
        expr: ast-get-path expr first path
        path: skip path 1
    ]
    reduce [expr skip block 1]
]

set-path!: make-type "set-path!"
set-path!/make: function [arguments] [] [
    make-struct [
        type: set-path!
        values: make-array
        pos: 0
    ]
]
set-path!/topaz-make: function [ignored] [] [
    apply 'set-path!/make [none]
]
set-path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: set-path!
        values: block/values
        pos: block/pos + 1
    ]
]
set-path!/head: function [block] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: 0
    ]
]
set-path!/tail: function [block] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: length-of-array block/values
    ]
]
set-path!/skip: function [block amount] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: block/pos + amount
    ]
]
set-path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
set-path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
set-path!/mold: function [block indent] [result pos] [
    result: ""
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result + #":"
]
set-path!/do: function [path block] [value set-to] [
    if 2 > length-of path [error "Internal" "SET-PATH! with less than two values" mold-value block ""]
    value: get first path
    path: skip path 1
    while [1 < length-of path] [
        value: get-path value first path
        path: skip path 1
    ]
    block: skip block 1
    if empty? block [error "Script" "set-path needs a value" mold-value skip block -1 ""]
    set [set-to block] do-step first block block
    set-path value first path set-to
    reduce [set-to block]
]
set-path!/bind: function [path context extend?] [] [
    bind-values path/values 0 context extend?
    path
]
ast-set-path: function [expr selector set-to] [] [
    switch selector/type/name [
        "paren!" [
            selector: compile selector
        ]
        "get-word!" [
            selector: ast-get selector
        ]
    ] [
        selector: ast-value selector
    ]
    make-struct [
        node-type: "set-path"
        expr: expr
        selector: selector
        set-to: set-to
        to-js: function [node context] [res sel] [
            either node/selector/node-type = "value/word!" [
                sel: "." + name-to-js node/selector/value/word
            ] [
                sel: rejoin ["[" to-js node/selector "expression" "]"]
            ]
            res: rejoin [
                to-js node/expr "expression" sel "="
                to-js node/set-to "expression"
            ]
            switch context [
                "return" [
                    rejoin ["return (" res ");"]
                ]
                "statement" [
                    res + ";"
                ]
                "expression" [
                    rejoin ["(" res ")"]
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
            ] []
        ]
    ]
]
compile-step: function [block] [] []
set-path!/compile: function [path block] [expr set-to] [
    if 2 > length-of path [error "Internal" "SET-PATH! with less than two values" mold-value block ""]
    expr: ast-get first path
    path: skip path 1
    while [1 < length-of path] [
        expr: ast-get-path expr first path
        path: skip path 1
    ]
    block: skip block 1
    if empty? block [error "Compile" "set-path needs a value" mold-value skip block -1 ""]
    set [set-to block] compile-step block
    reduce [ast-set-path expr first path set-to block]
]

lit-path!: make-type "lit-path!"
lit-path!/make: function [arguments] [] [
    make-struct [
        type: lit-path!
        values: make-array
        pos: 0
    ]
]
lit-path!/topaz-make: function [ignored] [] [
    apply 'lit-path!/make [none]
]
lit-path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: lit-path!
        values: block/values
        pos: block/pos + 1
    ]
]
lit-path!/head: function [block] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: 0
    ]
]
lit-path!/tail: function [block] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: length-of-array block/values
    ]
]
lit-path!/skip: function [block amount] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: block/pos + amount
    ]
]
lit-path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
lit-path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
lit-path!/mold: function [block indent] [result pos] [
    result: "'"
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result
]
lit-path!/do: function [path block] [] [
    path: make-struct [
        type: path!
        values: path/values
        pos: path/pos
    ]
    reduce [path skip block 1]
]
lit-path!/bind: function [path context extend?] [] [
    bind-values path/values 0 context extend?
    path
]
lit-path!/compile: function [path block] [] [
    reduce [
        ast-value make-struct [
            type: path!
            values: path/values
            pos: path/pos
        ]
        skip block 1
    ]
]

string!: make-type "string!"
string!/make: function [arguments] [] [
    make-struct [
        type: string!
        string: arguments
        pos: 0
    ]
]
string!/topaz-make: function [ignored] [] [
    apply 'string!/make [""]
]
string!/length-of: function [string] [] [
    (length-of-array string/string) - string/pos
]
string!/pick: function [string pos] [] [
    pick-array string/string string/pos + pos
]
string!/skip: function [string amount] [] [
    make-struct [
        type: string!
        string: string/string
        pos: string/pos + amount
    ]
]
escape: function [str] [re result match i] [
    re: regexp "[\x00-\x19^^^"]" "mg"
    result: ""
    i: 0
    while [match: apply 're/exec [str]] [
        result: result + apply 'str/substr [i match/index - i]
        switch pick-array str match/index [
            #"^^" [
                result: result + "^^^^"
            ]
            #"^/" [
                result: result + "^^/"
            ]
            #"^"" [
                result: result + "^^^""
            ]
            #"^-" [
                result: result + "^^-"
            ]
            #"^!" [
                result: result + "^^!"
            ]
        ] [
            result: rejoin [result #"^^" to-char (apply 'str/char-code-at [match/index]) + 64]
        ]
        i: match/index + 1
    ]
    either i = 0 [
        str
    ] [
        result + apply 'str/substr [i]
    ]
]
string!/mold: function [string indent] [] [
    rejoin ["^"" escape string/string #"^""]
]
string!/do: function [string block] [] [
    reduce [string skip block 1]
]
string!/bind: function [value context extend?] [] [
    value
]
string!/compile: function [string block] [] [
    reduce [ast-value string skip block 1]
]

char!: make-type "char!"
char!/make: function [arguments] [] [
    make-struct [
        type: char!
        string: arguments
    ]
]
char!/topaz-make: function [number] [] [
    apply 'char!/make [to-char number/number]
]
char!/mold: function [char indent] [] [
    rejoin ["#^"" escape char/string "^""]
]
char!/do: function [char block] [] [
    reduce [char skip block 1]
]
char!/bind: function [value context extend?] [] [
    value
]
char!/compile: function [char block] [] [
    reduce [ast-value char skip block 1]
]

none!: make-type "none!"
none!/make: function [ignored] [] [
    make-struct [
        type: none!
    ]
]
none!/topaz-make: function [ignored] [] [
    apply 'none!/make [none]
]
none!/mold: function [value indent] [] [
    "none"
]
none!/do: function [value block] [] [
    reduce [value skip block 1]
]
none!/bind: function [value context extend?] [] [
    value
]
none!/compile: function [value block] [] [
    reduce [ast-value value skip block 1]
]

logic!: make-type "logic!"
logic!/make: function [value] [] [
    make-struct [
        type: logic!
        value: value
    ]
]
logic!/topaz-make: function [value] [] [
    switch value/type/name [
        "none!" [apply 'logic!/make [false]]
        "logic!" [apply 'logic!/make [value/value]]
    ] [
        apply 'logic!/make [true]
    ]
]
logic!/mold: function [value indent] [] [
    either value/value [
        "true"
    ] [
        "false"
    ]
]
logic!/do: function [value block] [] [
    reduce [value skip block 1]
]
logic!/bind: function [value context extend?] [] [
    value
]
logic!/compile: function [value block] [] [
    reduce [ast-value value skip block 1]
]

number!: make-type "number!"
number!/make: function [arguments] [] [
    make-struct [
        type: number!
        number: arguments
    ]
]
number!/topaz-make: function [ignored] [] [
    apply 'number!/make [0]
]
number!/mold: function [number indent] [] [
    apply 'number/number/to-string []
]
number!/do: function [number block] [] [
    reduce [number skip block 1]
]
number!/bind: function [value context extend?] [] [
    value
]
number!/compile: function [number block] [] [
    reduce [ast-value number skip block 1]
]

word!: make-type "word!"
word!/make: function [arguments] [] [
    make-struct [
        type: word!
        word: arguments
        context: none
        offset: none
    ]
]
word!/topaz-make: function [string] [] [
    apply 'word!/make [string/string]
]
word!/mold: function [word indent] [] [
    word/word
]
word!/do: function [word block] [] [
    word: get word
    case [
        not word [
            error "Script" "Word has no value" mold-value block ""
        ]
        any [word/type/name = "function!" word/type/name = "native!"] [
            apply 'word/type/do [word block]
        ]
        'else [
            reduce [word skip block 1]
        ]
    ]
]
make-context: function [] [] [
    make-struct [
        words: make-array
        values: make-array
        stack: make-array
    ]
]
add-word: function [context word value] [l] [
    l: length-of-array context/words
    poke-array context/words l word/word
    poke-array context/values l value
    l
]
get-word-offset: function [context word] [] [
    apply 'context/words/index-of [word]
]
bind-word: function [context word add?] [offset] [
    offset: get-word-offset context word/word
    if all [add? offset < 0] [
        offset: add-word context word none
    ]
    if offset >= 0 [
        word/context: context
        word/offset: offset
    ]
    word
]
word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
word!/compile: function [word block] [value] [
    value: get word
    either all [value any [value/type/name = "function!" value/type/name = "native!"]] [
        apply 'value/type/compile [value block]
    ] [
        reduce [ast-get word skip block 1]
    ]
]

set-word!: make-type "set-word!"
set-word!/make: function [arguments] [] [
    make-struct [
        type: set-word!
        word: arguments
        context: none
        offset: none
    ]
]
set-word!/topaz-make: function [string] [] [
    apply 'set-word!/make [string/string]
]
set-word!/mold: function [word indent] [] [
    word/word + #":"
]
set-word: function [word value] [] [
    if not word/context [
        error "Script" "Word has no context" word/word
    ]
    poke-array word/context/values word/offset value
    value
]
set-word!/do: function [word block] [set-to] [
    block: skip block 1
    if empty? block [error "Script" "set-word needs a value" mold-value skip block -1 ""]
    set [set-to block] do-step first block block
    set-word word set-to
    reduce [set-to block]
]
set-word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
ast-set: function [word set-to] [] [
    if set-to/node-type = "function-definition" [
        set-word bind-word compile-words word true set-to/func
        set-to/func/name: word
    ]
    make-struct [
        node-type: "set"
        word: word
        set-to: set-to
        to-js: function [node context] [res words name i] [
            either node/word/type/name = "block!" [
                if context <> "statement" [
                    error "Compile" "SET with multiple words can only be a statement" ""
                ]
                words: node/word
                res: rejoin [
                    "var _tmp=" to-js node/set-to "expression" ";"
                ]
                i: 0
                while [i < length-of words] [
                    name: pick words i
                    res: rejoin [
                        res
                        name-to-js name/word "=_tmp[" i "];"
                    ]
                    i: i + 1
                ]
                res
            ] [
                res: rejoin [
                    name-to-js node/word/word "="
                    to-js node/set-to "expression"
                ]
                switch context [
                    "return" [
                        rejoin ["return (" res ");"]
                    ]
                    "statement" [
                        res + ";"
                    ]
                    "expression" [
                        rejoin ["(" res ")"]
                    ]
                    "paren" [
                        rejoin ["(" res ")"]
                    ]
                ] []
            ]
        ]
    ]
]
set-word!/compile: function [word block] [set-to] [
    block: skip block 1
    if empty? block [error "Compile" "set-word needs a value" mold-value skip block -1 ""]
    set [set-to block] compile-step block
    reduce [ast-set word set-to block]
]

lit-word!: make-type "lit-word!"
lit-word!/make: function [arguments] [] [
    make-struct [
        type: lit-word!
        word: arguments
        context: none
        offset: none
    ]
]
lit-word!/topaz-make: function [string] [] [
    apply 'lit-word!/make [string/string]
]
lit-word!/mold: function [word indent] [] [
    "'" + word/word
]
lit-word!/do: function [word block] [] [
    word: make-struct [
        type: word!
        word: word/word
        context: word/context
        offset: word/offset
    ]
    reduce [word skip block 1]
]
lit-word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
lit-word!/compile: function [word block] [] [
    reduce [
        ast-value make-struct [
            type: word!
            word: word/word
            context: word/context
            offset: word/offset
        ]
        skip block 1
    ]
]

function!: make-type "function!"
append: function [block value] [] [
    head insert tail block value
]
collect-set-words: function [set-words block] [value] [
    while [not empty? block] [
        value: first block
        switch value/type/name [
            "set-word!" [
                append set-words value
            ]
            "block!" [collect-set-words set-words value]
            "paren!" [collect-set-words set-words value]
        ] []
        block: skip block 1
    ]
    set-words
]
function!/make: function [arguments] [spec body context word] [
    set [spec body] arguments
    context: make-context
    while [not empty? spec] [
        word: first spec
        if word/type/name <> "word!" [
            error "Script" "Invalid function spec" mold-value spec ""
        ]
        if 0 <= get-word-offset context word/word [
            error "Script" "Duplicate function argument name" mold-value spec ""
        ]
        add-word context word none
        spec: skip spec 1
    ]
    bind collect-set-words make block! none body context true
    make-struct [
        type: function!
        context: context
        spec: head spec
        body: bind body context false
        name: none
    ]
]
function!/topaz-make: function [block] [] [
    apply 'function!/make [block/values]
]
function!/mold: function [func indent] [] [
    rejoin ["func " mold-value func/spec indent " " mold-value func/body indent]
]
clone-array: function [arr] [] [
    apply 'arr/concat []
]
push-context: function [context] [] [
    poke-array context/stack length-of-array context/stack context/values
    context/values: clone-array pick-array context/stack 0
]
pop-array: function [arr] [] [
    apply 'arr/pop []
]
pop-context: function [context] [] [
    context/values: pop-array context/stack
]
collect-arguments: function [n target block] [value orig-block i] [
    orig-block: block
    i: 0
    while [i < n] [
        if empty? block [
            error "Script" "Not enough arguments for function" mold-value skip orig-block -1 ""
        ]
        set [value block] do-step first block block
        poke-array target i value
        i: i + 1
    ]
    block
]
function!/do: function [func block] [result] [
    push-context func/context
    block: collect-arguments length-of func/spec func/context/values skip block 1
    result: do func/body
    pop-context func/context
    reduce [result block]
]
function!/bind: function [func context extend?] [] [
    func
]
ast-function-call: function [name args] [] [
    make-struct [
        node-type: "function-call"
        name: name
        args: args
        to-js: function [node context] [res i] [
            either node/name/type/name = "path!" [
                res: pick-array apply 'path!/compile [node/name make block! none] 0
                res: to-js res "expression"
            ] [
                res: name-to-js node/name/word
            ]
            res: res + "("
            if 0 < length-of-array node/args [
                res: res + to-js pick-array node/args 0 "expression"
                i: 1
                while [i < length-of-array node/args] [
                    res: rejoin [res "," to-js pick-array node/args i "expression"]
                    i: i + 1
                ]
            ]
            to-js-common res + ")" context
        ]
    ]
]
append-array: function [arr value] [] [
    apply 'arr/push [value]
]
compile-arguments: function [n block] [expr orig-block i args] [
    orig-block: block
    i: 0
    args: make-array
    while [i < n] [
        if empty? block [
            error "Compile" "Not enough arguments for function" mold-value skip orig-block -1 ""
        ]
        set [expr block] compile-step block
        append-array args expr
        i: i + 1
    ]
    reduce [args block]
]
function!/compile: function [func block] [args] [
    set [args block] compile-arguments length-of func/spec skip block 1
    reduce [
        ast-function-call func/name args
        block
    ]
]

native!: make-type "native!"
native!/make: function [arguments] [spec f c] [
    set [spec f c] arguments
    make-struct [
        type: native!
        args: make-array
        spec: spec
        func: f
        compile: c
    ]
]
native!/topaz-make: function [ignored] [] [
    error "Script" "Cannot make natives (yet)" ""
]
native!/mold: function [func indent] [] [
    "native " + mold-value func/spec indent
]
native!/do: function [func block] [] [
    block: collect-arguments length-of func/spec func/args skip block 1
    reduce [apply 'func/func [func/args] block]
]
native!/bind: function [func context extend?] [] [
    func
]
native!/compile: function [func block] [args] [
    set [args block] compile-arguments length-of func/spec skip block 1
    reduce [apply 'func/compile [args] block]
]

op!: make-type "op!"
op!/make: function [arguments] [] [
    if 2 <> length-of arguments/spec [
        error "Script" "Function must take exactly two arguments" ""
    ]
    make-struct [
        type: op!
        func: arguments
    ]
]
op!/topaz-make: function [func] [] [
    apply 'op!/make [func]
]
op!/mold: function [op indent] [] [
    "make op! " + mold-value op/func indent
]
op!/do: function [op block] [] [
    error "Script" "Infix use of OP!s is not supported" mold-value block ""
]
op!/bind: function [op context extend?] [] [
    op
]
op!/compile: function [op block] [] [
    error "Compile" "Infix use of OP!s is not supported" mold-value block ""
]
operator?: function [block] [value] [
    all [
        not empty? block
        value: first block
        value/type/name = "word!"
        value: get value
        value/type/name = "op!"
        value
    ]
]
do-op: function [op arg1 arg2] [result] [
    switch op/func/type/name [
        "function!" [
            push-context op/func/context
            poke-array op/func/context/values 0 arg1
            poke-array op/func/context/values 1 arg2
            result: do op/func/body
            pop-context op/func/context
            result
        ]
        "native!" [
            apply 'op/func/func [reduce [arg1 arg2]]
        ]
    ] []
]

to-js-string: function [string] [] [
    apply 'string/string/substr [string/pos]
]

new-line: function [block newline?] [] [
    poke-array block/newlines block/pos newline?
]
insert-nl: function [block value newline?] [] [
    block: insert block value
    poke-array block/newlines block/pos - 1 newline?
    block
]

exec-re: function [str re] [] [
    apply 're/exec [str]
]
test-re: function [str re] [] [
    apply 're/test [str]
]

skip-spaces: function [text] [t newline?] [
    t: exec-re to-js-string text regexp "^^(\s|;.*\n)+" ""
    newline?: false
    if t [
        t: pick-array t 0
        newline?: test-re t regexp "\n" ""
        text: skip text length-of-array t
    ]
    reduce [text newline?]
]

empty-array?: function [array] [] [
    0 = length-of-array array
]

parse-number: function [text] [t] [
    t: exec-re to-js-string text regexp "^^[-+]?[0-9]+(\.[0-9]*)?([Ee][-+]?[0-9]{1,3})?" ""
    if all [t  0 < length-of-array t: pick-array t 0] [
        reduce [
            make number! apply 'parse-float [t]
            skip text length-of-array t
        ]
    ]
]

parse-word-chars: function [text] [t] [
    if t: exec-re to-js-string text regexp "^^[!&*+\-.<=>?A-Z^^_`a-z|~-ÿ]['!&*+\-.0-9<=>?A-Z^^_`a-z|~-ÿ]*" "" [
        pick-array t 0
    ]
]

parse-word: function [text] [w] [
    if w: parse-word-chars text [
        reduce [
            make word! w
            skip text length-of-array w
        ]
    ]
]

parse-set-word: function [text] [w] [
    if all [w: parse-word-chars text  #":" = pick text length-of-array w] [
        reduce [
            make set-word! w
            skip text 1 + length-of-array w
        ]
    ]
]

parse-lit-word: function [text] [w] [
    if all [#"'" = first text  w: parse-word-chars skip text 1] [
        reduce [
            make lit-word! w
            skip text 1 + length-of-array w
        ]
    ]
]

parse-values: function [values text] [] []

parse-block: function [text] [values] [
    if #"[" = first text [
        set [values text] parse-values make block! none skip text 1
        if #"]" <> first text [
            error "Syntax" "Missing ]" to-js-string text
        ]
        reduce [values skip text 1]
    ]
]

parse-paren: function [text] [values] [
    if #"(" = first text [
        set [values text] parse-values make paren! none skip text 1
        if #")" <> first text [
            error "Syntax" "Missing )" to-js-string text
        ]
        reduce [values skip text 1]
    ]
]

unescape: function [str] [result i j ch p] [
    result: ""
    i: 0
    while [0 <= j: apply 'str/index-of [#"^^" i]] [
        result: result + apply 'str/substr [i j - i]
        ch: pick-array str j + 1
        switch ch [
            #"/" [
                result: result + #"^/"
                i: j + 2
            ]
            #"-" [
                result: result + #"^-"
                i: j + 2
            ]
            #"^^" [
                result: result + #"^^"
                i: j + 2
            ]
            #"!" [
                result: result + #"^!"
                i: j + 2
            ]
        ] [
            case [
                all [ch >= #"@"  ch <= #"_"] [
                    result: result + to-char (apply 'ch/char-code-at [0]) - 64
                    i: j + 2
                ]
                all [
                    ch = #"("
                    p: exec-re apply 'str/substr [j + 1] regexp "^^\(([0-9A-Fa-f]+)\)" ""
                ] [
                    result: result + to-char apply 'parse-int [pick-array p 1 16]
                    i: j + 1 + length-of-array pick-array p 0
                ]
                'else [
                    result: result + ch
                    i: j + 2
                ]
            ]
        ]
    ]
    either i = 0 [
        str
    ] [
        result + apply 'str/substr [i]
    ]
]

parse-string: function [text] [t] [
    if #"^"" = pick text 0 [
        t: exec-re to-js-string text regexp "^^^"(([^^^"^^\f\n\r]*|\^^\([0-9A-Fa-f]+\)|\^^[^^\f\n\r])*)^"" ""
        either t [
            reduce [
                make string! unescape pick-array t 1
                skip text length-of-array pick-array t 0
            ]
        ] [
            error "Syntax" "Missing ^"" to-js-string text
        ]
    ]
]

parse-char: function [text] [ch] [
    ch: exec-re to-js-string text regexp "^^#^"(\^^?.|\^^\([0-9A-Fa-f]+\))^"" ""
    if ch [
        reduce [
            make char! unescape pick-array ch 1
            skip text length-of-array pick-array ch 0
        ]
    ]
]

parse-path-element: function [text] [] [
    any [
        parse-number   text
        parse-word     text
        parse-string   text
        parse-block    text
        parse-paren    text
        parse-char     text
    ]
]

parse-set-path: function [text] [path value] [
    if all [value: parse-word-chars text  #"/" = pick text length-of-array value] [
        path: make set-path! none
        path: insert path make word! value
        text: skip text length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        if all [not empty? text  #":" = first text] [
            reduce [head path skip text 1]
        ]
    ]
]

parse-path: function [text] [path value] [
    if all [value: parse-word-chars text  #"/" = pick text length-of-array value] [
        path: make path! none
        path: insert path make word! value
        text: skip text length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        reduce [head path text]
    ]
]

parse-lit-path: function [text] [path value] [
    if all [#"'" = first text  value: parse-word-chars skip text 1  #"/" = pick text 1 + length-of-array value] [
        path: make lit-path! none
        path: insert path make word! value
        text: skip text 1 + length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        reduce [head path text]
    ]
]

parse-value: function [text] [] [
    any [
        parse-number   text
        parse-set-word text
        parse-set-path text
        parse-path     text
        parse-lit-path text
        parse-word     text
        parse-lit-word text
        parse-string   text
        parse-block    text
        parse-paren    text
        parse-char     text
    ]
]

parse-values: function [values text] [value newline?] [
    set [text newline?] skip-spaces text
    while [all [not empty? text  #"]" <> first text  #")" <> first text]] [
        set [value text] parse-value text
        either value [
            values: insert-nl values value newline?
            set [text newline?] skip-spaces text
        ] [
            error "Syntax" "Parse error" to-js-string text
        ]
    ]
    new-line values newline?
    reduce [head values text]
]

system-words: make-context
compile-words: make-context

load: function [text all?] [values] [
    set [values text] parse-values make block! none text
    if not empty? text [
        error "Syntax" "Parse error" to-js-string text
    ]
    bind values system-words true
    either all [not all? 1 = length-of values] [
        first values
    ] [
        values
    ]
]

do: function [block] [result] [
    result: none
    while [not empty? block] [
        set [result block] do-step first block block
    ]
    result
]

read: function [filename] [] [
    make string! apply 'fs/read-file-sync [filename "utf8"]
]

write: function [filename text] [] [
    apply 'fs/write-file-sync [filename text "utf8"]
    make none! none
]

run-test: function [block] [] [
    print ">> " probe block
    try [
        block: do block
        print "== " probe block
    ] 'err [
        print err + #"^/"
    ]
]

compile-op: function [op expr1 expr2] [] [
    switch op/func/type/name [
        "function!" [
            ast-function-call op/func/name reduce [expr1 expr2]
        ]
        "native!" [
            apply 'op/func/compile [reduce [expr1 expr2]]
         ]
    ] []
]

compile-step: function [block] [value expr op expr2] [
    value: first block
    set [expr block] apply 'value/type/compile [value block]
    while [op: operator? block] [
        block: skip block 1
        if empty? block [error "Compile" "Operator missing its second argument" mold-value skip block -2 ""]
        value: first block
        set [expr2 block] apply 'value/type/compile [value block]
        expr: compile-op op expr expr2
    ]
    reduce [expr block]
]

ast-expressions: function [list] [] [
    make-struct [
        node-type: "expressions"
        list: list
        to-js: function [node context] [i res] [
            i: 0
            res: ""
            switch context [
                "statement" [
                    while [i < length-of-array node/list] [
                        res: res + to-js pick-array node/list i "statement"
                        i: i + 1
                    ]
                ]
                "expression" [
                    if 1 < length-of-array node/list [
                        error "Compile" "Multiple expressions in expression context (eg. paren! with more than one expression)" ""
                    ]
                    res: to-js pick-array node/list 0 "expression"
                ]
                "paren" [
                    if 1 < length-of-array node/list [
                        error "Compile" "Multiple expressions in expression context (eg. paren! with more than one expression)" ""
                    ]
                    res: to-js pick-array node/list 0 "paren"
                ]
                "return" [
                    while [i + 1 < length-of-array node/list] [
                        res: res + to-js pick-array node/list i "statement"
                        i: i + 1
                    ]
                    either i < length-of-array node/list [
                        res: res + to-js pick-array node/list i "return"
                    ] [
                        res: "return null;"
                    ]
                ]
            ] []
            res
        ]
    ]
]

compile: function [block] [result expr] [
    result: make-array
    while [not empty? block] [
        set [expr block] compile-step block
        append-array result expr
    ]
    ast-expressions result
]

words: load make string! "datatype! make insert head pick length-of empty? skip mold do get bind tail probe block! paren! path! first set-path! lit-path! string! char! number! word! set-word! lit-word! function! append native! load reduce read run-test add subtract equal? greater? lesser? not-equal? greater-or-equal? lesser-or-equal? + - = > < <> >= <= op! compile write" true

set-word pick words 0 datatype!
set-word pick words 1 make native! reduce [
    load make string! "type arguments" true
    function [arguments] [type args] [
        set [type args] arguments
        apply 'type/topaz-make [args]
    ]
]
set-word pick words 2 make native! reduce [
    load make string! "series value" true
    function [arguments] [series value] [
        set [series value] arguments
        insert series value
    ]
]
set-word pick words 3 make native! reduce [
    load make string! "series" true
    function [arguments] [] [head pick-array arguments 0]
]
set-word pick words 4 make native! reduce [
    load make string! "series pos" true
    function [arguments] [series pos] [
        set [series pos] arguments
        pick series pos/number
    ]
]
set-word pick words 5 make native! reduce [
    load make string! "series" true
    function [arguments] [] [
        make number! length-of pick-array arguments 0
    ]
]
set-word pick words 6 make native! reduce [
    load make string! "series" true
    function [arguments] [] [
        make logic! empty? pick-array arguments 0
    ]
]
set-word pick words 7 make native! reduce [
    load make string! "series amount" true
    function [arguments] [series amount] [
        set [series amount] arguments
        skip series amount/number
    ]
]
set-word pick words 8 make native! reduce [
    load make string! "value" true
    function [arguments] [] [
        mold pick-array arguments 0
    ]
]
set-word pick words 9 make native! reduce [
    load make string! "block" true
    function [arguments] [] [
        do pick-array arguments 0
    ]
]
set-word pick words 10 make native! reduce [
    load make string! "word" true
    function [arguments] [word value] [
        value: get word: pick-array arguments 0
        if not value [
            error "Script" "Word has no value" mold-value word ""
        ]
        value
    ]
]
set-word pick words 11 make native! reduce [
    load make string! "words context" true
    function [arguments] [words context extend?] [
        set [words context] arguments
        bind words context/context false
    ]
]
set-word pick words 12 make native! reduce [
    load make string! "series" true
    function [arguments] [] [
        tail pick-array arguments 0
    ]
]
set-word pick words 13 make native! reduce [
    load make string! "value" true
    function [arguments] [value] [
        probe value: pick-array arguments 0
        value
    ]
]
set-word pick words 14 block!
set-word pick words 15 paren!
set-word pick words 16 path!
set-word pick words 17 make native! reduce [
    load make string! "series" true
    function [arguments] [] [
        first pick-array arguments 0
    ]
]
set-word pick words 18 set-path!
set-word pick words 19 lit-path!
set-word pick words 20 string!
set-word pick words 21 char!
set-word pick words 22 number!
set-word pick words 23 word!
set-word pick words 24 set-word!
set-word pick words 25 lit-word!
set-word pick words 26 function!
set-word pick words 27 make native! reduce [
    load make string! "series value" true
    function [arguments] [series value] [
        set [series value] arguments
        append series value
    ]
]
set-word pick words 28 native!
set-word pick words 29 make native! reduce [
    load make string! "text" true
    function [arguments] [] [
        load pick-array arguments 0 false
    ]
]
set-word pick words 30 make native! reduce [
    load make string! "block" true
    function [arguments] [block result value] [
        block: pick-array arguments 0
        result: make block! none
        while [not empty? block] [
            set [value block] do-step first block block
            append result value
        ]
        result
    ]
]
set-word pick words 31 make native! reduce [
    load make string! "filename" true
    function [arguments] [] [
        read to-js-string pick-array arguments 0
    ]
]
set-word pick words 32 make native! reduce [
    load make string! "block" true
    function [arguments] [] [
        run-test pick-array arguments 0
    ]
]
set-word pick words 33 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make number! val1/number + val2/number
    ]
]
set-word pick words 34 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make number! val1/number - val2/number
    ]
]
set-word pick words 35 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1 = val2
    ]
]
set-word pick words 36 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1/number > val2/number
    ]
]
set-word pick words 37 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1/number < val2/number
    ]
]
set-word pick words 38 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1 <> val2
    ]
]
set-word pick words 39 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1/number >= val2/number
    ]
]
set-word pick words 40 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1/number <= val2/number
    ]
]
set-word pick words 41 make op! get pick words 33
set-word pick words 42 make op! get pick words 34
set-word pick words 43 make op! get pick words 35
set-word pick words 44 make op! get pick words 36
set-word pick words 45 make op! get pick words 37
set-word pick words 46 make op! get pick words 38
set-word pick words 47 make op! get pick words 39
set-word pick words 48 make op! get pick words 40
set-word pick words 49 op!
set-word pick words 50 make native! reduce [
    load make string! "block" true
    function [arguments] [] [
        make string! to-js compile bind pick-array arguments 0 compile-words true "statement"
    ]
]
set-word pick words 51 make native! reduce [
    load make string! "filename text" true
    function [arguments] [] [
        write to-js-string pick-array arguments 0 to-js-string pick-array arguments 1
    ]
]

cwords: load make string! "function none true false throw set if either not make-struct apply reduce while make-array poke-array pick-array all any regexp switch case to-char try + = - > < <> >= <= rejoin" true

bind cwords compile-words true

words-to-js: function [words] [res word] [
    res: ""
    if 0 < length-of words [
        word: first words
        res: name-to-js word/word
        words: skip words 1
        while [not empty? words] [
            word: first words
            res: rejoin [res "," name-to-js word/word]
            words: skip words 1
        ]
    ]
    res
]
ast-function-definition: function [spec locals body] [] [
    make-struct [
        node-type: "function-definition"
        spec: spec
        locals: locals
        body: body
        func: make function! reduce [spec make block! none]
        to-js: function [node context] [res] [
            res: rejoin ["function(" words-to-js node/spec "){"]
            if not empty? node/locals [
                res: rejoin [res "var " words-to-js node/locals ";"]
            ]
            res: rejoin [
                res
                to-js node/body "return"
                "}"
            ]
            switch context [
                "return" [
                    rejoin ["return " res ";"]
                ]
                "expression" [res]
                "paren" [
                    rejoin ["(" res ")"]
                ]
                "statement" [
                    error "Compile" "Function definition cannot be used as a statement" ""
                ]
            ] []
        ]
    ]
]
set-word pick cwords 0 make native! reduce [
    load make string! "spec locals body" true
    none
    function [arguments] [spec locals body] [
        set [spec locals body] arguments
        ast-function-definition spec/value locals/value compile body/value
    ]
]
set-word pick cwords 1 make native! reduce [
    make block! none
    none
    function [arguments] [] [
        ast-value make none! none
    ]
]
set-word pick cwords 2 make native! reduce [
    make block! none
    none
    function [arguments] [] [
        ast-value make logic! true
    ]
]
set-word pick cwords 3 make native! reduce [
    make block! none
    none
    function [arguments] [] [
        ast-value make logic! false
    ]
]
ast-throw: function [expr] [] [
    make-struct [
        node-type: "throw"
        expr: expr
        to-js: function [node context] [res] [
            res: rejoin ["throw " to-js node/expr "expression" ";"]
            switch context [
                "expression" [
                    error "Compile" "THROW cannot be used as an expression" ""
                ]
                "statement" [
                    res
                ]
                "paren" [
                    error "Compile" "THROW cannot be used as an expression" ""
                ]
                "return" [
                    res
                ]
            ] []
        ]
    ]
]
set-word pick cwords 4 make native! reduce [
    load make string! "value" true
    none
    function [arguments] [] [
        ast-throw pick-array arguments 0
    ]
]
set-word pick cwords 5 make native! reduce [
    load make string! "word value" true
    none
    function [arguments] [word expr] [
        set [word expr] arguments
        ast-set word/value expr
    ]
]
either-expr-to-js: function [node] [res] [
    res: rejoin [
        to-js node/condition "paren" " ? "
        to-js node/true-body "paren" " : "
    ]
    either node/false-body [
        res + to-js node/false-body "paren"
    ] [
        res + "null"
    ]
]
either-stmt-to-js: function [node context] [res] [
    res: rejoin [
        "if(" to-js node/condition "expression" "){"
        to-js node/true-body context
        "}"
    ]
    if node/false-body [
        either node/false-body/node-type = "either" [
            res: rejoin [
                res "else " to-js node/false-body context
            ]
        ] [
            res: rejoin [
                res "else{"
                to-js node/false-body context
                "}"
            ]
        ]
    ]
    res
]
ast-either: function [condition true-body false-body] [] [
    make-struct [
        node-type: "either"
        condition: condition
        true-body: true-body
        false-body: false-body
        to-js: function [node context] [] [
            switch context [
                "statement" [
                    either-stmt-to-js node "statement"
                ]
                "expression" [
                    either-expr-to-js node
                ]
                "paren" [
                    rejoin ["(" either-expr-to-js node ")"]
                ]
                "return" [
                    either-stmt-to-js node "return"
                ]
            ] []
        ]
    ]
]
set-word pick cwords 6 make native! reduce [
    load make string! "condition body" true
    none
    function [arguments] [condition body] [
        set [condition body] arguments
        ast-either condition compile body/value none
    ]
]
set-word pick cwords 7 make native! reduce [
    load make string! "condition true-body false-body" true
    none
    function [arguments] [condition true-body false-body] [
        set [condition true-body false-body] arguments
        ast-either condition compile true-body/value compile false-body/value
    ]
]
ast-not: function [expr] [] [
    make-struct [
        node-type: "not"
        expr: expr
        to-js: function [node context] [] [
            to-js-common "!" + to-js node/expr "paren" context
        ]
    ]
]
set-word pick cwords 8 make native! reduce [
    load make string! "value" true
    none
    function [arguments] [] [
        ast-not pick-array arguments 0
    ]
]
ast-struct: function [spec] [] [
    make-struct [
        node-type: "struct"
        spec: spec
        to-js: function [node context] [res i name expr] [
            res: "{"
            if 0 < length-of-array node/spec [
                name: pick-array node/spec 0
                expr: pick-array node/spec 1
                res: rejoin [res name-to-js name ":" to-js expr "expression"]
                i: 2
                while [i < length-of-array node/spec] [
                    name: pick-array node/spec i
                    expr: pick-array node/spec i + 1
                    res: rejoin [res "," name-to-js name ":" to-js expr "expression"]
                    i: i + 2
                ]
            ]
            to-js-common res + "}" context
        ]
    ]
]
parse-struct-spec: function [block] [result name expr] [
    block: block/value
    result: make-array
    while [not empty? block] [
        name: first block
        if name/type/name <> "set-word!" [
            error "Compile" "Invalid struct spec, expected set-word!, not " + name/type/name mold-value block ""
        ]
        block: skip block 1
        if empty? block [
            error "Compile" "Struct field is missing its value" mold-value skip block -1 ""
        ]
        set [expr block] compile-step block
        append-array result name/word
        append-array result expr
    ]
    result
]
set-word pick cwords 9 make native! reduce [
    load make string! "spec" true
    none
    function [arguments] [] [
        ast-struct parse-struct-spec pick-array arguments 0
    ]
]
compile-reduce: function [block] [result expr] [
    result: make-array
    while [not empty? block] [
        set [expr block] compile-step block
        append-array result expr
    ]
    result
]
set-word pick cwords 10 make native! reduce [
    load make string! "func-name args" true
    none
    function [arguments] [func-name args] [
        set [func-name args] arguments
        ast-function-call func-name/value compile-reduce args/value
    ]
]
ast-reduce: function [exprs] [] [
    make-struct [
        node-type: "reduce"
        exprs: exprs
        to-js: function [node context] [res i expr] [
            res: "["
            if 0 < length-of-array node/exprs [
                expr: pick-array node/exprs 0
                res: rejoin [res to-js expr "expression"]
                i: 1
                while [i < length-of-array node/exprs] [
                    expr: pick-array node/exprs i
                    res: rejoin [res "," to-js expr "expression"]
                    i: i + 1
                ]
            ]
            to-js-common res + "]" context
        ]
    ]
]
set-word pick cwords 11 make native! reduce [
    load make string! "block" true
    none
    function [arguments] [block] [
        block: pick-array arguments 0
        ast-reduce compile-reduce block/value
    ]
]
ast-while: function [condition body] [] [
    make-struct [
        node-type: "while"
        condition: condition
        body: body
        to-js: function [node context] [] [
            either context = "statement" [
                rejoin [
                    "while(" to-js node/condition "expression" "){"
                    to-js node/body "statement"
                    "}"
                ]
            ] [
                error "Compile" "WHILE can only be used as a statement" ""
            ]
        ]
    ]
]
set-word pick cwords 12 make native! reduce [
    load make string! "condition body" true
    none
    function [arguments] [condblock condition body] [
        set [condblock body] arguments
        condblock: condblock/value
        if empty? condblock [
            error "Compile" "WHILE's condition block cannot be empty" ""
        ]
        set [condition condblock] compile-step condblock
        if not empty? condblock [
            error "Compile" "WHILE's condition block can only have one expression" mold-value head condblock ""
        ]
        ast-while condition compile body/value
    ]
]
set-word pick cwords 13 make native! reduce [
    make block! none
    none
    function [arguments] [] [
        ast-reduce make-array
    ]
]
ast-poke: function [arr pos value] [] [
    make-struct [
        node-type: "poke"
        arr: arr
        pos: pos
        value: value
        to-js: function [node context] [res] [
            res: rejoin [
                to-js node/arr "paren" "["
                to-js node/pos "expression" "]="
                to-js node/value "expression"
            ]
            switch context [
                "return" [
                    rejoin ["return (" res ");"]
                ]
                "statement" [
                    res + ";"
                ]
                "expression" [
                    rejoin ["(" res ")"]
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
            ] []
        ]
    ]
]
set-word pick cwords 14 make native! reduce [
    load make string! "arr pos value" true
    none
    function [arguments] [arr pos value] [
        set [arr pos value] arguments
        ast-poke arr pos value
    ]
]
ast-pick: function [arr pos] [] [
    make-struct [
        node-type: "pick"
        arr: arr
        pos: pos
        to-js: function [node context] [] [
            to-js-common rejoin [to-js node/arr "paren" "[" to-js node/pos "expression" "]"] context
        ]
    ]
]
set-word pick cwords 15 make native! reduce [
    load make string! "arr pos" true
    none
    function [arguments] [arr pos] [
        set [arr pos] arguments
        ast-pick arr pos
    ]
]
ast-all: function [exprs] [] [
    make-struct [
        node-type: "all"
        exprs: exprs
        to-js: function [node context] [res i] [
            res: to-js pick-array node/exprs 0 "paren"
            i: 1
            while [i < length-of-array node/exprs] [
                res: rejoin [res "&&" to-js pick-array node/exprs i "paren"]
                i: i + 1
            ]
            switch context [
                "statement" [
                    error "Compile" "ALL cannot be used as a statement" ""
                ]
                "expression" [
                    res
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
                "return" [
                    rejoin ["return " res ";"]
                ]
            ] []
        ]
    ]
]
set-word pick cwords 16 make native! reduce [
    load make string! "block" true
    none
    function [arguments] [block] [
        block: pick-array arguments 0
        ast-all compile-reduce block/value
    ]
]
ast-any: function [exprs] [] [
    make-struct [
        node-type: "any"
        exprs: exprs
        to-js: function [node context] [res i] [
            res: to-js pick-array node/exprs 0 "paren"
            i: 1
            while [i < length-of-array node/exprs] [
                res: rejoin [res "||" to-js pick-array node/exprs i "paren"]
                i: i + 1
            ]
            switch context [
                "statement" [
                    error "Compile" "ANY cannot be used as a statement" ""
                ]
                "expression" [
                    res
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
                "return" [
                    rejoin ["return " res ";"]
                ]
            ] []
        ]
    ]
]
set-word pick cwords 17 make native! reduce [
    load make string! "block" true
    none
    function [arguments] [block] [
        block: pick-array arguments 0
        ast-any compile-reduce block/value
    ]
]
ast-regexp: function [exp flags] [] [
    make-struct [
        node-type: "regexp"
        exp: exp
        flags: flags
        to-js: function [node context] [] [
            to-js-common rejoin ["/" to-js-string node/exp "/" to-js-string node/flags] context
        ]
    ]
]
set-word pick cwords 18 make native! reduce [
    load make string! "exp flags" true
    none
    function [arguments] [exp flags] [
        set [exp flags] arguments
        ast-regexp exp/value flags/value
    ]
]
ast-switch: function [value cases def] [] [
    make-struct [
        node-type: "switch"
        value: value
        cases: cases
        def: def
        to-js: function [node context] [res i a-case] [
            switch context [
                "statement" [
                    res: rejoin ["switch(" to-js node/value "expression" "){"]
                    i: 0
                    while [i < length-of-array node/cases] [
                        a-case: pick-array node/cases i
                        res: rejoin [
                            res
                            "case " to-js a-case/value "expression" ":"
                            to-js a-case/expr "statement"
                            "break;"
                        ]
                        i: i + 1
                    ]
                    rejoin [
                        res
                        "default:"
                        to-js node/def "statement"
                        "}"
                    ]
                ]
                "expression" [
                    error "Compile" "SWITCH cannot be used as an expression" ""
                ]
                "paren" [
                    error "Compile" "SWITCH cannot be used as an expression" ""
                ]
                "return" [
                    res: rejoin ["switch(" to-js node/value "expression" "){"]
                    i: 0
                    while [i < length-of-array node/cases] [
                        a-case: pick-array node/cases i
                        res: rejoin [
                            res
                            "case " to-js a-case/value "expression" ":"
                            to-js a-case/expr "return"
                        ]
                        i: i + 1
                    ]
                    rejoin [
                        res
                        "default:"
                        to-js node/def "return"
                        "}"
                    ]
                ]
            ] []
        ]
    ]
]
set-word pick cwords 19 make native! reduce [
    load make string! "value cases default" true
    none
    function [arguments] [value cases def expr compiled-cases] [
        set [value cases def] arguments
        cases: cases/value
        def: def/value
        compiled-cases: make-array
        while [not empty? cases] [
            set [expr cases] compile-step cases
            append-array compiled-cases make-struct [
                value: expr
                expr: compile first cases
            ]
            cases: skip cases 1
        ]
        ast-switch value compiled-cases compile def
    ]
]
compile-cases: function [cases] [] []
compile-cases: function [cases] [cond orig-cases] [
    either empty? cases [
        none
    ] [
        orig-cases: cases
        set [cond cases] compile-step cases
        if empty? cases [
            error "Compile" "Missing case block after condition" mold-value orig-cases ""
        ]
        either cond/node-type = "value/word!" [
            compile first cases
        ] [
            ast-either cond compile first cases compile-cases skip cases 1
        ]
    ]
]
set-word pick cwords 20 make native! reduce [
    load make string! "cases" true
    none
    function [arguments] [cases expr] [
        cases: pick-array arguments 0
        if empty? cases/value [
            error "Compile" "CASE needs at least one case" ""
        ]
        compile-cases cases/value
    ]
]
ast-to-char: function [expr] [] [
    make-struct [
        node-type: "to-char"
        expr: expr
        to-js: function [node context] [] [
            to-js-common rejoin [
                "String.fromCharCode(" to-js node/expr "expression" ")"
            ] context
        ]
    ]
]
set-word pick cwords 21 make native! reduce [
    load make string! "number" true
    none
    function [arguments] [] [
        ast-to-char pick-array arguments 0
    ]
]
try-to-js: function [code name def context] [] [
    rejoin [
        "try{"
        to-js code context
        "}catch(" name-to-js name "){"
        to-js def context
        "}"
    ]
]
ast-try: function [code word def] [] [
    make-struct [
        node-type: "try"
        code: code
        word: word
        def: def
        to-js: function [node context] [] [
            switch context [
                "statement" [
                    try-to-js node/code node/word/word node/def "statement"
                ]
                "expression" [
                    error "Compile" "TRY cannot be used as an expression" ""
                ]
                "paren" [
                    error "Compile" "TRY cannot be used as an expression" ""
                ]
                "return" [
                    try-to-js node/code node/word/word node/def "return"
                ]
            ] []
        ]
    ]
]
set-word pick cwords 22 make native! reduce [
    load make string! "code word default" true
    none
    function [arguments] [code word def] [
        set [code word def] arguments
        ast-try compile code/value word/value compile def/value
    ]
]
ast-op: function [op val1 val2] [] [
    make-struct [
        node-type: "op/" + op
        op: op
        val1: val1
        val2: val2
        to-js: function [node context] [res] [
            res: rejoin [to-js node/val1 "paren" node/op to-js node/val2 "paren"]
            switch context [
                "statement" [
                    error "Compile" "Cannot use operator as a statement" ""
                ]
                "expression" [
                    res
                ]
                "paren" [
                    rejoin ["(" res ")"]
                ]
                "return" [
                    rejoin ["return " res ";"]
                ]
            ] []
        ]
    ]
]
set-word pick cwords 23 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "+" val1 val2
    ]
]
set-word pick cwords 24 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "==" val1 val2
    ]
]
set-word pick cwords 25 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "-" val1 val2
    ]
]
set-word pick cwords 26 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op ">" val1 val2
    ]
]
set-word pick cwords 27 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "<" val1 val2
    ]
]
set-word pick cwords 28 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "!=" val1 val2
    ]
]
set-word pick cwords 29 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op ">=" val1 val2
    ]
]
set-word pick cwords 30 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "<=" val1 val2
    ]
]
set-word pick cwords 31 make native! reduce [
    load make string! "block" true
    none
    function [arguments] [block expr res] [
        block: pick-array arguments 0
        block: block/value
        either empty? block [
            ast-value make string! ""
        ] [
            set [res block] compile-step block
            while [not empty? block] [
                set [expr block] compile-step block
                res: ast-op "+" res expr
            ]
            res
        ]
    ]
]


sys: apply 'require ["sys"]
fs: apply 'require ["fs"]

do load read "topaz/init.topaz" true

either 2 < length-of-array process/argv [
    try [
        do load read pick-array process/argv 2 true
    ] 'e [
        print e + "^/"
    ]
] [
    print "Topaz Interpreter - (C) 2011 Gabriele Santilli - MIT License^/"
    stdin: apply 'process/open-stdin []
    apply 'stdin/set-encoding ["utf8"]
    apply 'stdin/add-listener [
        "data"
        function [chunk] [res] [
            either chunk = "quit^/" [
                apply 'stdin/destroy []
            ] [
                try [
                    chunk: do load make string! chunk true
                    print "== " probe chunk
                    print ">> "
                ] 'e [
                    print e + "^/>> "
                ]
            ]
        ]
    ]
    print ">> "
]
