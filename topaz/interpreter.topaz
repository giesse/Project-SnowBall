
print: function [text] [] [
    apply 'sys/print [text]
]

length-of-array: function [arr] [] [
    arr/length
]

insert-array: function [arr pos value] [] [
    apply 'arr/splice [pos 0 value]
]

error: function [type message where] [] [
    throw rejoin ["*** " type " error: " message "^/*** Where: " where]
]

datatype!: none

make-type: function [name] [] [
    make-struct [
        type: datatype!
        name: name
        make: none
        insert: none
        head: none
        pick: none
        length-of: none
        skip: none
        mold: none
        do: none
        get-path: none
        set-path: none
        bind: none
        tail: none
        topaz-make: none
        compile: none
    ]
]
datatype!: make-type "datatype!"
datatype!/type: datatype!
datatype!/mold: function [type indent] [] [
    type/name
]
datatype!/do: function [type block] [] [
    reduce [type skip block 1]
]
datatype!/bind: function [type context extend?] [] [
    type
]
datatype!/topaz-make: function [ignored] [] [
    error "Script" "Cannot make datatypes (yet)" ""
]
ast-value: function [value] [] [
    make-struct [
        value: value
        fun-def?: false
        to-js: function [node statement? return?] [res] [
            switch node/value/type/name [
                "string!" [
                    res: apply 'JSON/stringify [node/value/string]
                ]
                "char!" [
                    res: apply 'JSON/stringify [node/value/string]
                ]
                "number!" [
                    res: apply 'node/value/number/to-string []
                ]
            ] [
                error "JS emitter" rejoin ["Cannot represent " node/value/type/name " values in JS"] ""
            ]
            either return? [
                rejoin ["return " res ";"]
            ] [
                res
            ]
        ]
    ]
]
datatype!/compile: function [type block] [] [
    reduce [ast-value type skip block 1]
]

make: function [type arguments] [] [
    apply 'type/make [arguments]
]
insert: function [series value] [] [
    apply 'series/type/insert [series value]
]
head: function [series] [] [
    apply 'series/type/head [series]
]
pick: function [series pos] [] [
    apply 'series/type/pick [series pos]
]
length-of: function [series] [] [
    apply 'series/type/length-of [series]
]
empty?: function [series] [] [
    0 = length-of series
]
skip: function [series amount] [] [
    apply 'series/type/skip [series amount]
]
mold-value: function [value indent] [] [
    apply 'value/type/mold [value indent]
]
mold: function [value] [] [
    make string! mold-value value ""
]
operator?: function [block] [] []
do-op: function [op arg1 arg2] [] []
first: function [series] [] [
    pick series 0
]
do-step: function [value block] [result arg2 op] [
    set [result block] apply 'value/type/do [value block]
    while [op: operator? block] [
        block: skip block 1
        if empty? block [error "Script" "Operator missing its second argument" mold-value skip block -2 ""]
        arg2: first block
        set [arg2 block] apply 'arg2/type/do [arg2 block]
        result: do-op op result arg2
    ]
    reduce [result block]
]
do: function [block] [] []
get: function [word] [] [
    if not word/context [
        error "Script" "Word has no context" word/word
    ]
    pick-array word/context/values word/offset
]
get-path: function [value selector] [] [
    switch selector/type/name [
        "paren!" [
            selector: do selector
        ]
        "get-word!" [
            selector: get selector
        ]
    ] []
    apply 'value/type/get-path [value selector]
]
set-path: function [value selector set-to] [] [
    switch selector/type/name [
        "paren!" [
            selector: do selector
        ]
        "get-word!" [
            selector: get selector
        ]
    ] []
    apply 'value/type/set-path [value selector set-to]
]
bind: function [words context extend?] [] [
    apply 'words/type/bind [words context extend?]
]
tail: function [series] [] [
    apply 'series/type/tail [series]
]

probe: function [value] [] [
    print apply 'value/type/mold [value ""]
    print "^/"
]

block!: make-type "block!"
block!/make: function [arguments] [] [
    make-struct [
        type: block!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
block!/topaz-make: function [ignored] [] [
    apply 'block!/make [none]
]
block!/insert: function [block value] [] [
    insert-array block/values block/pos value
    insert-array block/newlines block/pos false
    make-struct [
        type: block!
        values: block/values
        pos: block/pos + 1
        newlines: block/newlines
    ]
]
block!/head: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
block!/tail: function [block] [] [
    make-struct [
        type: block!
        values: block/values
        pos: length-of-array block/values
        newlines: block/newlines
    ]
]
block!/skip: function [block amount] [] [
    make-struct [
        type: block!
        values: block/values
        pos: block/pos + amount
        newlines: block/newlines
    ]
]
block!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
block!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
mold-step1: function [result values pos indent sep] [] [
    rejoin [result sep mold-value pick-array values pos indent]
]
mold-step2: function [result values newlines pos indent sep nlsep] [] [
    if pick-array newlines pos [
        sep: nlsep + indent
    ]
    mold-step1 result values pos indent sep
]
block!/mold: function [block indent] [result pos ind] [
    result: "["
    pos: block/pos
    ind: indent + "    "
    if pos < length-of-array block/values [
        result: mold-step2 result block/values block/newlines pos ind "" #"^/"
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step2 result block/values block/newlines pos ind #" " #"^/"
            pos: pos + 1
        ]
    ]
    if pick-array block/newlines pos [result: rejoin [result #"^/" indent]]
    result + #"]"
]
block!/do: function [block container] [] [
    reduce [block skip container 1]
]
block!/bind: function [words context extend?] [pos] [
    pos: words/pos
    while [pos < length-of-array words/values] [
        bind pick-array words/values pos context extend?
        pos: pos + 1
    ]
    words
]
block!/compile: function [block container] [] [
    reduce [ast-value block skip container 1]
]

paren!: make-type "paren!"
paren!/make: function [arguments] [] [
    make-struct [
        type: paren!
        values: make-array
        pos: 0
        newlines: make-array
    ]
]
paren!/topaz-make: function [ignored] [] [
    apply 'paren!/make [none]
]
paren!/insert: function [block value] [] [
    insert-array block/values block/pos value
    insert-array block/newlines block/pos false
    make-struct [
        type: paren!
        values: block/values
        pos: block/pos + 1
        newlines: block/newlines
    ]
]
paren!/head: function [block] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: 0
        newlines: block/newlines
    ]
]
paren!/tail: function [block] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: length-of-array block/values
        newlines: block/newlines
    ]
]
paren!/skip: function [block amount] [] [
    make-struct [
        type: paren!
        values: block/values
        pos: block/pos + amount
        newlines: block/newlines
    ]
]
paren!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
paren!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
paren!/mold: function [block indent] [result pos ind] [
    result: "("
    pos: block/pos
    ind: indent + "    "
    if pos < length-of-array block/values [
        result: mold-step2 result block/values block/newlines pos ind "" #"^/"
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step2 result block/values block/newlines pos ind #" " #"^/"
            pos: pos + 1
        ]
    ]
    if pick-array block/newlines pos [result: rejoin [result #"^/" indent]]
    result + #")"
]
paren!/do: function [paren block] [] [
    reduce [do paren skip block 1]
]
paren!/bind: function [words context extend?] [pos] [
    pos: words/pos
    while [pos < length-of-array words/values] [
        bind pick-array words/values pos context extend?
        pos: pos + 1
    ]
    words
]
compile: function [block] [] []
to-js: function [node statement? return?] [] [
    apply 'node/to-js [node statement? return?]
]
ast-paren: function [expressions] [] [
    make-struct [
        expressions: expressions
        fun-def?: false
        to-js: function [node statement? return?] [res] [
            either return? [
                res: "return ("
            ] [
                res: "("
            ]
            rejoin [res to-js node/expressions false false ")"]
        ]
    ]
]
paren!/compile: function [paren block] [] [
    reduce [ast-paren compile paren skip block 1]
]

path!: make-type "path!"
path!/make: function [arguments] [] [
    make-struct [
        type: path!
        values: make-array
        pos: 0
    ]
]
path!/topaz-make: function [ignored] [] [
    apply 'path!/make [none]
]
path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: path!
        values: block/values
        pos: block/pos + 1
    ]
]
path!/head: function [block] [] [
    make-struct [
        type: path!
        values: block/values
        pos: 0
    ]
]
path!/tail: function [block] [] [
    make-struct [
        type: path!
        values: block/values
        pos: length-of-array block/values
    ]
]
path!/skip: function [block amount] [] [
    make-struct [
        type: path!
        values: block/values
        pos: block/pos + amount
    ]
]
path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
path!/mold: function [block indent] [result pos] [
    result: ""
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result
]
path!/do: function [path block] [value] [
    if empty? path [error "Internal" "Empty PATH! value" mold-value block ""]
    value: get first path
    path: skip path 1
    while [not empty? path] [
        value: get-path value first path
        path: skip path 1
    ]
    either value/type/name = "function!" [
        apply 'value/type/do [value block]
    ] [
        reduce [value skip block 1]
    ]
]
path!/bind: function [path context extend?] [] [
    bind pick-array path/values 0 context extend?
    path
]
name-to-js: function [name] [] [
    switch name [
        "arguments" ["_arguments"]
        "do"        ["_do"]
        "json"      ["JSON"]
    ] [
        name: apply 'name/replace [
            regexp "-(.)" "g"
            function [match chr] [] [
                apply 'chr/to-upper-case []
            ]
        ]
        name: apply 'name/replace [
            regexp "^^(.)(.*)\?$" ""
            function [match chr rest] [] [
                rejoin ["is" apply 'chr/to-upper-case [] rest]
            ]
        ]
        apply 'name/replace ["!" "_type"]
    ]
]
to-js-common: function [js-text statement? return?] [] [
    case [
        return? [
            rejoin ["return " js-text ";"]
        ]
        statement? [
            js-text + ";"
        ]
        'else [
            js-text
        ]
    ]
]
ast-get: function [word] [] [
    make-struct [
        word: word
        fun-def?: false
        to-js: function [node statement? return?] [] [
            to-js-common name-to-js node/word/word statement? return?
        ]
    ]
]
ast-get-path: function [expr selector] [] [
    switch selector/type/name [
        "paren!" [
            selector: compile selector
        ]
        "get-word!" [
            selector: ast-get selector
        ]
    ] [
        selector: ast-value selector
    ]
    make-struct [
        expr: expr
        selector: selector
        fun-def?: false
        to-js: function [node statement? return?] [] [
            to-js-common rejoin [to-js node/expr false false "[" to-js node/selector false false "]"] statement? return?
        ]
    ]
]
path!/compile: function [path block] [expr] [
    if empty? path [error "Internal" "Empty PATH! value" mold-value block ""]
    expr: ast-get first path
    path: skip path 1
    while [not empty? path] [
        expr: ast-get-path expr first path
        path: skip path 1
    ]
    reduce [expr skip block 1]
]

set-path!: make-type "set-path!"
set-path!/make: function [arguments] [] [
    make-struct [
        type: set-path!
        values: make-array
        pos: 0
    ]
]
set-path!/topaz-make: function [ignored] [] [
    apply 'set-path!/make [none]
]
set-path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: set-path!
        values: block/values
        pos: block/pos + 1
    ]
]
set-path!/head: function [block] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: 0
    ]
]
set-path!/tail: function [block] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: length-of-array block/values
    ]
]
set-path!/skip: function [block amount] [] [
    make-struct [
        type: set-path!
        values: block/values
        pos: block/pos + amount
    ]
]
set-path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
set-path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
set-path!/mold: function [block indent] [result pos] [
    result: ""
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result + #":"
]
set-path!/do: function [path block] [value set-to] [
    if 2 > length-of path [error "Internal" "SET-PATH! with less than two values" mold-value block ""]
    value: get first path
    path: skip path 1
    while [1 < length-of path] [
        value: get-path value first path
        path: skip path 1
    ]
    block: skip block 1
    if empty? block [error "Script" "set-path needs a value" mold-value skip block -1 ""]
    set [set-to block] do-step first block block
    set-path value first path set-to
    reduce [set-to block]
]
set-path!/bind: function [path context extend?] [] [
    bind pick-array path/values 0 context extend?
    path
]
ast-set-path: function [expr selector set-to] [] [
    switch selector/type/name [
        "paren!" [
            selector: compile selector
        ]
        "get-word!" [
            selector: ast-get selector
        ]
    ] [
        selector: ast-value selector
    ]
    make-struct [
        expr: expr
        selector: selector
        set-to: set-to
        fun-def?: false
        to-js: function [node statement? return?] [res] [
            res: rejoin [
                to-js node/expr false false
                "["
                to-js node/selector false false
                "]="
                to-js node/set-to false false
            ]
            case [
                return? [
                    rejoin ["return (" res ");"]
                ]
                statement? [
                    res + ";"
                ]
                'else [
                    rejoin ["(" res ")"]
                ]
            ]
        ]
    ]
]
set-path!/compile: function [path block] [expr set-to] [
    if 2 > length-of path [error "Internal" "SET-PATH! with less than two values" mold-value block ""]
    expr: ast-get first path
    path: skip path 1
    while [1 < length-of path] [
        expr: ast-get-path expr first path
        path: skip path 1
    ]
    block: skip block 1
    if empty? block [error "Compile" "set-path needs a value" mold-value skip block -1 ""]
    set [set-to block] compile-step block
    reduce [ast-set-path expr first path set-to block]
]

lit-path!: make-type "lit-path!"
lit-path!/make: function [arguments] [] [
    make-struct [
        type: lit-path!
        values: make-array
        pos: 0
    ]
]
lit-path!/topaz-make: function [ignored] [] [
    apply 'lit-path!/make [none]
]
lit-path!/insert: function [block value] [] [
    insert-array block/values block/pos value
    make-struct [
        type: lit-path!
        values: block/values
        pos: block/pos + 1
    ]
]
lit-path!/head: function [block] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: 0
    ]
]
lit-path!/tail: function [block] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: length-of-array block/values
    ]
]
lit-path!/skip: function [block amount] [] [
    make-struct [
        type: lit-path!
        values: block/values
        pos: block/pos + amount
    ]
]
lit-path!/pick: function [block pos] [] [
    pick-array block/values block/pos + pos
]
lit-path!/length-of: function [block] [] [
    (length-of-array block/values) - block/pos
]
lit-path!/mold: function [block indent] [result pos] [
    result: "'"
    pos: block/pos
    if pos < length-of-array block/values [
        result: mold-step1 result block/values pos indent ""
        pos: pos + 1
        while [pos < length-of-array block/values] [
            result: mold-step1 result block/values pos indent #"/"
            pos: pos + 1
        ]
    ]
    result
]
lit-path!/do: function [path block] [] [
    path: make-struct [
        type: path!
        values: path/values
        pos: path/pos
    ]
    reduce [path skip block 1]
]
lit-path!/bind: function [path context extend?] [] [
    bind pick-array path/values 0 context extend?
    path
]
lit-path!/compile: function [path block] [] [
    reduce [
        ast-value make-struct [
            type: path!
            values: path/values
            pos: path/pos
        ]
        skip block 1
    ]
]

string!: make-type "string!"
string!/make: function [arguments] [] [
    make-struct [
        type: string!
        string: arguments
        pos: 0
    ]
]
string!/topaz-make: function [ignored] [] [
    apply 'string!/make [""]
]
string!/length-of: function [string] [] [
    (length-of-array string/string) - string/pos
]
string!/pick: function [string pos] [] [
    pick-array string/string string/pos + pos
]
string!/skip: function [string amount] [] [
    make-struct [
        type: string!
        string: string/string
        pos: string/pos + amount
    ]
]
escape: function [str] [re result match i] [
    re: regexp "[\x00-\x19^^^"]" "mg"
    result: ""
    i: 0
    while [match: apply 're/exec [str]] [
        result: result + apply 'str/substr [i match/index - i]
        switch pick-array str match/index [
            #"^^" [
                result: result + "^^^^"
            ]
            #"^/" [
                result: result + "^^/"
            ]
            #"^"" [
                result: result + "^^^""
            ]
            #"^-" [
                result: result + "^^-"
            ]
            #"^!" [
                result: result + "^^!"
            ]
        ] [
            result: rejoin [result #"^^" to-char (apply 'str/char-code-at [match/index]) + 64]
        ]
        i: match/index + 1
    ]
    either i = 0 [
        str
    ] [
        result + apply 'str/substr [i]
    ]
]
string!/mold: function [string indent] [] [
    rejoin ["^"" escape string/string #"^""]
]
string!/do: function [string block] [] [
    reduce [string skip block 1]
]
string!/bind: function [value context extend?] [] [
    value
]
string!/compile: function [string block] [] [
    reduce [ast-value string skip block 1]
]

char!: make-type "char!"
char!/make: function [arguments] [] [
    make-struct [
        type: char!
        string: arguments
    ]
]
char!/topaz-make: function [number] [] [
    apply 'char!/make [to-char number/number]
]
char!/mold: function [char indent] [] [
    rejoin ["#^"" escape char/string "^""]
]
char!/do: function [char block] [] [
    reduce [char skip block 1]
]
char!/bind: function [value context extend?] [] [
    value
]
char!/compile: function [char block] [] [
    reduce [ast-value char skip block 1]
]

none!: make-type "none!"
none!/make: function [ignored] [] [
    make-struct [
        type: none!
    ]
]
none!/topaz-make: function [ignored] [] [
    apply 'none!/make [none]
]
none!/mold: function [value indent] [] [
    "none"
]
none!/do: function [value block] [] [
    reduce [value skip block 1]
]
none!/bind: function [value context extend?] [] [
    value
]
none!/compile: function [value block] [] [
    reduce [ast-value value skip block 1]
]

logic!: make-type "logic!"
logic!/make: function [value] [] [
    make-struct [
        type: logic!
        value: value
    ]
]
logic!/topaz-make: function [value] [] [
    switch value/type/name [
        "none!" [apply 'logic!/make [false]]
        "logic!" [apply 'logic!/make [value/value]]
    ] [
        apply 'logic!/make [true]
    ]
]
logic!/mold: function [value indent] [] [
    either value/value [
        "true"
    ] [
        "false"
    ]
]
logic!/do: function [value block] [] [
    reduce [value skip block 1]
]
logic!/bind: function [value context extend?] [] [
    value
]
logic!/compile: function [value block] [] [
    reduce [ast-value value skip block 1]
]

number!: make-type "number!"
number!/make: function [arguments] [] [
    make-struct [
        type: number!
        number: arguments
    ]
]
number!/topaz-make: function [ignored] [] [
    apply 'number!/make [0]
]
number!/mold: function [number indent] [] [
    apply 'number/number/to-string []
]
number!/do: function [number block] [] [
    reduce [number skip block 1]
]
number!/bind: function [value context extend?] [] [
    value
]
number!/compile: function [number block] [] [
    reduce [ast-value number skip block 1]
]

word!: make-type "word!"
word!/make: function [arguments] [] [
    make-struct [
        type: word!
        word: arguments
        context: none
        offset: none
    ]
]
word!/topaz-make: function [string] [] [
    apply 'word!/make [string/string]
]
word!/mold: function [word indent] [] [
    word/word
]
word!/do: function [word block] [] [
    word: get word
    case [
        not word [
            error "Script" "Word has no value" mold-value block ""
        ]
        any [word/type/name = "function!" word/type/name = "native!"] [
            apply 'word/type/do [word block]
        ]
        'else [
            reduce [word skip block 1]
        ]
    ]
]
make-context: function [] [] [
    make-struct [
        words: make-array
        values: make-array
        stack: make-array
    ]
]
add-word: function [context word value] [l] [
    l: length-of-array context/words
    poke-array context/words l word/word
    poke-array context/values l value
    l
]
get-word-offset: function [context word] [] [
    apply 'context/words/index-of [word]
]
bind-word: function [context word add?] [offset] [
    offset: get-word-offset context word/word
    if all [add? offset < 0] [
        offset: add-word context word none
    ]
    if offset >= 0 [
        word/context: context
        word/offset: offset
    ]
    word
]
word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
word!/compile: function [word block] [value] [
    value: get word
    either all [value any [value/type/name = "function!" value/type/name = "native!"]] [
        apply 'value/type/compile [value block]
    ] [
        reduce [ast-get word skip block 1]
    ]
]

set-word!: make-type "set-word!"
set-word!/make: function [arguments] [] [
    make-struct [
        type: set-word!
        word: arguments
        context: none
        offset: none
    ]
]
set-word!/topaz-make: function [string] [] [
    apply 'set-word!/make [string/string]
]
set-word!/mold: function [word indent] [] [
    word/word + #":"
]
set-word: function [word value] [] [
    if not word/context [
        error "Script" "Word has no context" word/word
    ]
    poke-array word/context/values word/offset value
    value
]
set-word!/do: function [word block] [set-to] [
    block: skip block 1
    if empty? block [error "Script" "set-word needs a value" mold-value skip block -1 ""]
    set [set-to block] do-step first block block
    set-word word set-to
    reduce [set-to block]
]
set-word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
ast-set: function [word set-to] [] [
    if set-to/fun-def? [
        set-word bind-word compile-words word true set-to/func
        set-to/func/name: word
    ]
    make-struct [
        word: word
        set-to: set-to
        fun-def?: false
        to-js: function [node statement? return?] [res] [
            res: rejoin [
                name-to-js node/word/word
                to-js node/set-to false false
            ]
            case [
                return? [
                    rejoin ["return (" res ");"]
                ]
                statement? [
                    res + ";"
                ]
                'else [
                    rejoin ["(" res ")"]
                ]
            ]
        ]
    ]
]
set-word!/compile: function [word block] [set-to] [
    block: skip block 1
    if empty? block [error "Compile" "set-word needs a value" mold-value skip block -1 ""]
    set [set-to block] compile-step block
    reduce [ast-set word set-to block]
]

lit-word!: make-type "lit-word!"
lit-word!/make: function [arguments] [] [
    make-struct [
        type: lit-word!
        word: arguments
        context: none
        offset: none
    ]
]
lit-word!/topaz-make: function [string] [] [
    apply 'lit-word!/make [string/string]
]
lit-word!/mold: function [word indent] [] [
    "'" + word/word
]
lit-word!/do: function [word block] [] [
    word: make-struct [
        type: word!
        word: word/word
        context: word/context
        offset: word/offset
    ]
    reduce [word skip block 1]
]
lit-word!/bind: function [word context extend?] [] [
    bind-word context word extend?
]
lit-word!/compile: function [word block] [] [
    reduce [
        ast-value make-struct [
            type: word!
            word: word/word
            context: word/context
            offset: word/offset
        ]
        skip block 1
    ]
]

function!: make-type "function!"
append: function [block value] [] [
    head insert tail block value
]
collect-set-words: function [set-words block] [value] [
    while [not empty? block] [
        value: first block
        switch value/type/name [
            "set-word!" [
                append set-words value
            ]
            "block!" [collect-set-words set-words value]
            "paren!" [collect-set-words set-words value]
        ] []
        block: skip block 1
    ]
    set-words
]
function!/make: function [arguments] [spec body context word] [
    set [spec body] arguments
    context: make-context
    while [not empty? spec] [
        word: first spec
        if word/type/name <> "word!" [
            error "Script" "Invalid function spec" mold-value spec ""
        ]
        if 0 <= get-word-offset context word/word [
            error "Script" "Duplicate function argument name" mold-value spec ""
        ]
        add-word context word none
        spec: skip spec 1
    ]
    bind collect-set-words make block! none body context true
    make-struct [
        type: function!
        context: context
        spec: head spec
        body: bind body context false
        name: none
    ]
]
function!/topaz-make: function [block] [] [
    apply 'function!/make [block/values]
]
function!/mold: function [func indent] [] [
    rejoin ["func " mold-value func/spec indent " " mold-value func/body indent]
]
clone-array: function [arr] [] [
    apply 'arr/concat []
]
push-context: function [context] [] [
    poke-array context/stack length-of-array context/stack context/values
    context/values: clone-array pick-array context/stack 0
]
pop-array: function [arr] [] [
    apply 'arr/pop []
]
pop-context: function [context] [] [
    context/values: pop-array context/stack
]
collect-arguments: function [n target block] [value orig-block i] [
    orig-block: block
    i: 0
    while [i < n] [
        if empty? block [
            error "Script" "Not enough arguments for function" mold-value skip orig-block -1 ""
        ]
        set [value block] do-step first block block
        poke-array target i value
        i: i + 1
    ]
    block
]
function!/do: function [func block] [result] [
    push-context func/context
    block: collect-arguments length-of func/spec func/context/values skip block 1
    result: do func/body
    pop-context func/context
    reduce [result block]
]
function!/bind: function [func context extend?] [] [
    func
]
ast-function-call: function [name args] [] [
    make-struct [
        name: name
        args: args
        fun-def?: false
        to-js: function [node statement? return?] [res i] [
            either node/name/type/name = "path!" [
                res: pick-array apply 'path!/compile [node/name make block! none] 0
                res: to-js res false false
            ] [
                res: name-to-js node/name/word
            ]
            res: res + "("
            if 0 < length-of-array node/args [
                res: res + to-js pick-array node/args 0 false false
                i: 1
                while [i < length-of-array node/args] [
                    res: rejoin [res "," to-js pick-array node/args i false false]
                    i: i + 1
                ]
            ]
            to-js-common res + ")" statement? return?
        ]
    ]
]
append-array: function [arr value] [] [
    apply 'arr/push [value]
]
compile-arguments: function [n block] [expr orig-block i args] [
    orig-block: block
    i: 0
    args: make-array
    while [i < n] [
        if empty? block [
            error "Compile" "Not enough arguments for function" mold-value skip orig-block -1 ""
        ]
        set [expr block] compile-step block
        append-array args expr
        i: i + 1
    ]
    reduce [args block]
]
function!/compile: function [func block] [args] [
    set [args block] compile-arguments length-of func/spec skip block 1
    reduce [
        ast-function-call func/name args
        block
    ]
]

native!: make-type "native!"
native!/make: function [arguments] [spec f c] [
    set [spec f c] arguments
    make-struct [
        type: native!
        args: make-array
        spec: spec
        func: f
        compile: c
    ]
]
native!/topaz-make: function [ignored] [] [
    error "Script" "Cannot make natives (yet)" ""
]
native!/mold: function [func indent] [] [
    "native " + mold-value func/spec indent
]
native!/do: function [func block] [] [
    block: collect-arguments length-of func/spec func/args skip block 1
    reduce [apply 'func/func [func/args] block]
]
native!/bind: function [func context extend?] [] [
    func
]
native!/compile: function [func block] [args] [
    set [args block] compile-arguments length-of func/spec skip block 1
    reduce [apply 'func/compile [args] block]
]

op!: make-type "op!"
op!/make: function [arguments] [] [
    if 2 <> length-of arguments/spec [
        error "Script" "Function must take exactly two arguments" ""
    ]
    make-struct [
        type: op!
        func: arguments
    ]
]
op!/topaz-make: function [func] [] [
    apply 'op!/make [func]
]
op!/mold: function [op indent] [] [
    "make op! " + mold-value op/func indent
]
op!/do: function [op block] [] [
    error "Script" "Infix use of OP!s is not supported" mold-value block ""
]
op!/bind: function [op context extend?] [] [
    op
]
op!/compile: function [op block] [] [
    error "Compile" "Infix use of OP!s is not supported" mold-value block ""
]
operator?: function [block] [value] [
    all [
        not empty? block
        value: first block
        value/type/name = "word!"
        value: get value
        value/type/name = "op!"
        value
    ]
]
do-op: function [op arg1 arg2] [result] [
    switch op/func/type/name [
        "function!" [
            push-context op/func/context
            poke-array op/func/context/values 0 arg1
            poke-array op/func/context/values 1 arg2
            result: do op/func/body
            pop-context op/func/context
            result
        ]
        "native!" [
            apply 'op/func/func [reduce [arg1 arg2]]
        ]
    ] []
]

to-js-string: function [string] [] [
    apply 'string/string/substr [string/pos]
]

new-line: function [block newline?] [] [
    poke-array block/newlines block/pos newline?
]
insert-nl: function [block value newline?] [] [
    block: insert block value
    poke-array block/newlines block/pos - 1 newline?
    block
]

exec-re: function [str re] [] [
    apply 're/exec [str]
]
test-re: function [str re] [] [
    apply 're/test [str]
]

skip-spaces: function [text] [t newline?] [
    t: exec-re to-js-string text regexp "^^(\s|;.*\n)+" ""
    newline?: false
    if t [
        t: pick-array t 0
        newline?: test-re t regexp "\n" ""
        text: skip text length-of-array t
    ]
    reduce [text newline?]
]

empty-array?: function [array] [] [
    0 = length-of-array array
]

parse-number: function [text] [t] [
    t: exec-re to-js-string text regexp "^^[-+]?[0-9]+(\.[0-9]*)?([Ee][-+]?[0-9]{1,3})?" ""
    if all [t  0 < length-of-array t: pick-array t 0] [
        reduce [
            make number! apply 'parse-float [t]
            skip text length-of-array t
        ]
    ]
]

parse-word-chars: function [text] [t] [
    if t: exec-re to-js-string text regexp "^^[!&*+\-.<=>?A-Z^^_`a-z|~-ÿ]['!&*+\-.0-9<=>?A-Z^^_`a-z|~-ÿ]*" "" [
        pick-array t 0
    ]
]

parse-word: function [text] [w] [
    if w: parse-word-chars text [
        reduce [
            make word! w
            skip text length-of-array w
        ]
    ]
]

parse-set-word: function [text] [w] [
    if all [w: parse-word-chars text  #":" = pick text length-of-array w] [
        reduce [
            make set-word! w
            skip text 1 + length-of-array w
        ]
    ]
]

parse-lit-word: function [text] [w] [
    if all [#"'" = first text  w: parse-word-chars skip text 1] [
        reduce [
            make lit-word! w
            skip text 1 + length-of-array w
        ]
    ]
]

parse-values: function [values text] [] []

parse-block: function [text] [values] [
    if #"[" = first text [
        set [values text] parse-values make block! none skip text 1
        if #"]" <> first text [
            error "Syntax" "Missing ]" to-js-string text
        ]
        reduce [values skip text 1]
    ]
]

parse-paren: function [text] [values] [
    if #"(" = first text [
        set [values text] parse-values make paren! none skip text 1
        if #")" <> first text [
            error "Syntax" "Missing )" to-js-string text
        ]
        reduce [values skip text 1]
    ]
]

unescape: function [str] [result i j ch p] [
    result: ""
    i: 0
    while [0 <= j: apply 'str/index-of [#"^^" i]] [
        result: result + apply 'str/substr [i j - i]
        ch: pick-array str j + 1
        switch ch [
            #"/" [
                result: result + #"^/"
                i: j + 2
            ]
            #"-" [
                result: result + #"^-"
                i: j + 2
            ]
            #"^^" [
                result: result + #"^^"
                i: j + 2
            ]
            #"!" [
                result: result + #"^!"
                i: j + 2
            ]
        ] [
            case [
                all [ch >= #"@"  ch <= #"_"] [
                    result: result + to-char (apply 'ch/char-code-at [0]) - 64
                    i: j + 2
                ]
                all [
                    ch = #"("
                    p: exec-re apply 'str/substr [j + 1] regexp "^^\(([0-9A-Fa-f]+)\)" ""
                ] [
                    result: result + to-char apply 'parse-int [pick-array p 1 16]
                    i: j + 1 + length-of-array pick-array p 0
                ]
                'else [
                    result: result + ch
                    i: j + 2
                ]
            ]
        ]
    ]
    either i = 0 [
        str
    ] [
        result + apply 'str/substr [i]
    ]
]

parse-string: function [text] [t] [
    if #"^"" = pick text 0 [
        t: exec-re to-js-string text regexp "^^^"(([^^^"^^\f\n\r]*|\^^\([0-9A-Fa-f]+\)|\^^[^^\f\n\r])*)^"" ""
        either t [
            reduce [
                make string! unescape pick-array t 1
                skip text length-of-array pick-array t 0
            ]
        ] [
            error "Syntax" "Missing ^"" to-js-string text
        ]
    ]
]

parse-char: function [text] [ch] [
    ch: exec-re to-js-string text regexp "^^#^"(\^^?.|\^^\([0-9A-Fa-f]+\))^"" ""
    if ch [
        reduce [
            make char! unescape pick-array ch 1
            skip text length-of-array pick-array ch 0
        ]
    ]
]

parse-path-element: function [text] [] [
    any [
        parse-number   text
        parse-word     text
        parse-string   text
        parse-block    text
        parse-paren    text
        parse-char     text
    ]
]

parse-set-path: function [text] [path value] [
    if all [value: parse-word-chars text  #"/" = pick text length-of-array value] [
        path: make set-path! none
        path: insert path make word! value
        text: skip text length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        if all [not empty? text  #":" = first text] [
            reduce [head path skip text 1]
        ]
    ]
]

parse-path: function [text] [path value] [
    if all [value: parse-word-chars text  #"/" = pick text length-of-array value] [
        path: make path! none
        path: insert path make word! value
        text: skip text length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        reduce [head path text]
    ]
]

parse-lit-path: function [text] [path value] [
    if all [#"'" = first text  value: parse-word-chars skip text 1  #"/" = pick text 1 + length-of-array value] [
        path: make lit-path! none
        path: insert path make word! value
        text: skip text 1 + length-of-array value
        while [all [not empty? text  #"/" = first text]] [
            set [value text] parse-path-element skip text 1
            either value [
                path: insert path value
            ] [
                error "Syntax" "Parse error" to-js-string text
            ]
        ]
        reduce [head path text]
    ]
]

parse-value: function [text] [] [
    any [
        parse-number   text
        parse-set-word text
        parse-set-path text
        parse-path     text
        parse-lit-path text
        parse-word     text
        parse-lit-word text
        parse-string   text
        parse-block    text
        parse-paren    text
        parse-char     text
    ]
]

parse-values: function [values text] [value newline?] [
    set [text newline?] skip-spaces text
    while [all [not empty? text  #"]" <> first text  #")" <> first text]] [
        set [value text] parse-value text
        either value [
            values: insert-nl values value newline?
            set [text newline?] skip-spaces text
        ] [
            error "Syntax" "Parse error" to-js-string text
        ]
    ]
    new-line values newline?
    reduce [head values text]
]

system-words: make-context
compile-words: make-context

load: function [text all?] [values] [
    set [values text] parse-values make block! none text
    if not empty? text [
        error "Syntax" "Parse error" to-js-string text
    ]
    bind values system-words true
    either all [not all? 1 = length-of values] [
        first values
    ] [
        values
    ]
]

do: function [block] [result] [
    result: none
    while [not empty? block] [
        set [result block] do-step first block block
    ]
    result
]

read: function [filename] [] [
    make string! apply 'fs/read-file-sync [filename "utf8"]
]

run-test: function [block] [] [
    print ">> " probe block
    try [
        block: do block
        print "== " probe block
    ] 'err [
        print err + #"^/"
    ]
]

compile-op: function [op expr1 expr2] [] [
    switch op/func/type/name [
        "function!" [
            ast-function-call op/func/name reduce [expr1 expr2]
        ]
        "native!" [
            apply 'op/func/compile [reduce [expr1 expr2]]
         ]
    ] []
]

compile-step: function [block] [value expr op expr2] [
    value: first block
    set [expr block] apply 'value/type/compile [value block]
    while [op: operator? block] [
        block: skip block 1
        if empty? block [error "Compile" "Operator missing its second argument" mold-value skip block -2 ""]
        value: first block
        set [expr2 block] apply 'value/type/compile [value block]
        expr: compile-op op expr expr2
    ]
    reduce [expr block]
]

ast-expressions: function [list] [] [
    make-struct [
        list: list
        fun-def?: false
    ]
]

compile: function [block] [result expr] [
    result: make-array
    while [not empty? block] [
        set [expr block] compile-step block
        append-array result expr
    ]
    ast-expressions result
]

words: load make string! "datatype! make insert head pick length-of empty? skip mold do get bind tail probe block! paren! path! first set-path! lit-path! string! char! number! word! set-word! lit-word! function! append native! load reduce read run-test add subtract equal? greater? lesser? not-equal? greater-or-equal? lesser-or-equal? + - = > < <> >= <= op!" true

set-word pick words 0 datatype!
set-word pick words 1 make native! reduce [
    load make string! "type arguments" true
    function [arguments] [type args] [
        set [type args] arguments
        apply 'type/topaz-make [args]
    ]
]
set-word pick words 2 make native! reduce [
    load make string! "series value" true
    function [arguments] [series value] [
        set [series value] arguments
        insert series value
    ]
]
set-word pick words 3 make native! reduce [
    load make string! "series" true
    function [arguments] [] [head pick-array arguments 0]
]
set-word pick words 4 make native! reduce [
    load make string! "series pos" true
    function [arguments] [series pos] [
        set [series pos] arguments
        pick series pos/number
    ]
]
set-word pick words 5 make native! reduce [
    load make string! "series" true
    function [arguments] [] [
        make number! length-of pick-array arguments 0
    ]
]
set-word pick words 6 make native! reduce [
    load make string! "series" true
    function [arguments] [] [
        make logic! empty? pick-array arguments 0
    ]
]
set-word pick words 7 make native! reduce [
    load make string! "series amount" true
    function [arguments] [series amount] [
        set [series amount] arguments
        skip series amount/number
    ]
]
set-word pick words 8 make native! reduce [
    load make string! "value" true
    function [arguments] [] [
        mold pick-array arguments 0
    ]
]
set-word pick words 9 make native! reduce [
    load make string! "block" true
    function [arguments] [] [
        do pick-array arguments 0
    ]
]
set-word pick words 10 make native! reduce [
    load make string! "word" true
    function [arguments] [word value] [
        value: get word: pick-array arguments 0
        if not value [
            error "Script" "Word has no value" mold-value word ""
        ]
        value
    ]
]
set-word pick words 11 make native! reduce [
    load make string! "words context" true
    function [arguments] [words context extend?] [
        set [words context] arguments
        bind words context/context false
    ]
]
set-word pick words 12 make native! reduce [
    load make string! "series" true
    function [arguments] [] [
        tail pick-array arguments 0
    ]
]
set-word pick words 13 make native! reduce [
    load make string! "value" true
    function [arguments] [value] [
        probe value: pick-array arguments 0
        value
    ]
]
set-word pick words 14 block!
set-word pick words 15 paren!
set-word pick words 16 path!
set-word pick words 17 make native! reduce [
    load make string! "series" true
    function [arguments] [] [
        first pick-array arguments 0
    ]
]
set-word pick words 18 set-path!
set-word pick words 19 lit-path!
set-word pick words 20 string!
set-word pick words 21 char!
set-word pick words 22 number!
set-word pick words 23 word!
set-word pick words 24 set-word!
set-word pick words 25 lit-word!
set-word pick words 26 function!
set-word pick words 27 make native! reduce [
    load make string! "series value" true
    function [arguments] [series value] [
        set [series value] arguments
        append series value
    ]
]
set-word pick words 28 native!
set-word pick words 29 make native! reduce [
    load make string! "text" true
    function [arguments] [] [
        load pick-array arguments 0 false
    ]
]
set-word pick words 30 make native! reduce [
    load make string! "block" true
    function [arguments] [block result value] [
        block: pick-array arguments 0
        result: make block! none
        while [not empty? block] [
            set [value block] do-step first block block
            append result value
        ]
        result
    ]
]
set-word pick words 31 make native! reduce [
    load make string! "filename" true
    function [arguments] [] [
        read to-js-string pick-array arguments 0
    ]
]
set-word pick words 32 make native! reduce [
    load make string! "block" true
    function [arguments] [] [
        run-test pick-array arguments 0
    ]
]
set-word pick words 33 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make number! val1/number + val2/number
    ]
]
set-word pick words 34 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make number! val1/number - val2/number
    ]
]
set-word pick words 35 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1 = val2
    ]
]
set-word pick words 36 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1/number > val2/number
    ]
]
set-word pick words 37 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1/number < val2/number
    ]
]
set-word pick words 38 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1 <> val2
    ]
]
set-word pick words 39 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1/number >= val2/number
    ]
]
set-word pick words 40 make native! reduce [
    load make string! "val1 val2" true
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        make logic! val1/number <= val2/number
    ]
]
set-word pick words 41 make op! get pick words 33
set-word pick words 42 make op! get pick words 34
set-word pick words 43 make op! get pick words 35
set-word pick words 44 make op! get pick words 36
set-word pick words 45 make op! get pick words 37
set-word pick words 46 make op! get pick words 38
set-word pick words 47 make op! get pick words 39
set-word pick words 48 make op! get pick words 40
set-word pick words 49 op!

cwords: load make string! "function none true false throw set if either not make-struct apply reduce while make-array poke-array pick-array all any regexp switch case to-char try + = - > < <> >= <=" true

bind cwords compile-words true

ast-function-definition: function [spec locals body] [] [
    make-struct [
        spec: spec
        locals: locals
        body: body
        fun-def?: true
        func: make function! reduce [spec make block! none]
    ]
]
set-word pick cwords 0 make native! reduce [
    load make string! "spec locals body" true
    none
    function [arguments] [spec locals body] [
        set [spec locals body] arguments
        ast-function-definition spec/value spec/locals compile body/value
    ]
]
set-word pick cwords 1 make native! reduce [
    make block! none
    none
    function [arguments] [] [
        ast-value make none! none
    ]
]
set-word pick cwords 2 make native! reduce [
    make block! none
    none
    function [arguments] [] [
        ast-value make logic! true
    ]
]
set-word pick cwords 3 make native! reduce [
    make block! none
    none
    function [arguments] [] [
        ast-value make logic! false
    ]
]
ast-throw: function [expr] [] [
    make-struct [
        expr: expr
        fun-def?: false
    ]
]
set-word pick cwords 4 make native! reduce [
    load make string! "value" true
    none
    function [arguments] [] [
        ast-throw pick-array arguments 0
    ]
]
set-word pick cwords 5 make native! reduce [
    load make string! "word value" true
    none
    function [arguments] [word expr] [
        set [word expr] arguments
        ast-set word/value expr
    ]
]
ast-either: function [condition true-body false-body] [] [
    make-struct [
        condition: condition
        true-body: true-body
        false-body: false-body
        fun-def?: false
    ]
]
set-word pick cwords 6 make native! reduce [
    load make string! "condition body" true
    none
    function [arguments] [condition body] [
        set [condition body] arguments
        ast-either condition compile body/value none
    ]
]
set-word pick cwords 7 make native! reduce [
    load make string! "condition true-body false-body" true
    none
    function [arguments] [condition true-body false-body] [
        set [condition true-body false-body] arguments
        ast-either condition compile true-body/value compile false-body/value
    ]
]
ast-not: function [expr] [] [
    make-struct [
        expr: expr
        fun-def?: false
    ]
]
set-word pick cwords 8 make native! reduce [
    load make string! "value" true
    none
    function [arguments] [] [
        ast-not pick-array arguments 0
    ]
]
ast-struct: function [spec] [] [
    make-struct [
        spec: spec
        fun-def?: false
    ]
]
parse-struct-spec: function [block] [result name expr] [
    result: make-array
    while [not empty? block] [
        name: first block
        if name/type/name <> "set-word!" [
            error "Compile" "Invalid struct spec, expected set-word!, not " + name/type/name mold-value block ""
        ]
        block: skip block 1
        if empty? block [
            error "Compile" "Struct field is missing its value" mold-value skip block -1 ""
        ]
        set [expr block] compile-step block
        append-array result name/word
        append-array result expr
    ]
    result
]
set-word pick cwords 9 make native! reduce [
    load make string! "spec" true
    none
    function [arguments] [] [
        ast-struct parse-struct-spec pick-array arguments 0
    ]
]
compile-reduce: function [block] [result expr] [
    result: make-array
    while [not empty? block] [
        set [expr block] compile-step block
        append-array result expr
    ]
    result
]
set-word pick cwords 10 make native! reduce [
    load make string! "func-name args" true
    none
    function [arguments] [func-name args] [
        set [func-name args] arguments
        ast-function-call func-name/value compile-reduce args/value
    ]
]
ast-reduce: function [exprs] [] [
    make-struct [
        exprs: exprs
        fun-def?: false
    ]
]
set-word pick cwords 11 make native! reduce [
    load make string! "block" true
    none
    function [arguments] [block] [
        block: pick-array arguments 0
        ast-reduce compile-reduce block/value
    ]
]
ast-while: function [condition body] [] [
    make-struct [
        condition: condition
        body: body
        fun-def?: false
    ]
]
set-word pick cwords 12 make native! reduce [
    load make string! "condition body" true
    none
    function [arguments] [condblock condition body] [
        set [condblock body] arguments
        condblock: condblock/value
        if empty? condblock [
            error "Compile" "WHILE's condition block cannot be empty" ""
        ]
        set [condition condblock] compile-step condblock
        if not empty? condblock [
            error "Compile" "WHILE's condition block can only have one expression" mold-value head condblock ""
        ]
        ast-while condition compile body/value
    ]
]
set-word pick cwords 13 make native! reduce [
    make block! none
    none
    function [arguments] [] [
        ast-reduce make-array
    ]
]
ast-poke: function [arr pos value] [] [
    make-struct [
        arr: arr
        pos: pos
        value: value
        fun-def?: false
    ]
]
set-word pick cwords 14 make native! reduce [
    load make string! "arr pos value" true
    none
    function [arguments] [arr pos value] [
        set [arr pos value] arguments
        ast-poke arr pos value
    ]
]
ast-pick: function [arr pos] [] [
    make-struct [
        arr: arr
        pos: pos
        fun-def?: false
    ]
]
set-word pick cwords 15 make native! reduce [
    load make string! "arr pos" true
    none
    function [arguments] [arr pos] [
        set [arr pos] arguments
        ast-pick arr pos
    ]
]
ast-all: function [exprs] [] [
    make-struct [
        exprs: exprs
        fun-def?: false
    ]
]
set-word pick cwords 16 make native! reduce [
    load make string! "block" true
    none
    function [arguments] [block] [
        block: pick-array arguments 0
        ast-all compile-reduce block/value
    ]
]
ast-any: function [exprs] [] [
    make-struct [
        exprs: exprs
        fun-def?: false
    ]
]
set-word pick cwords 17 make native! reduce [
    load make string! "block" true
    none
    function [arguments] [block] [
        block: pick-array arguments 0
        ast-any compile-reduce block/value
    ]
]
ast-regexp: function [exp flags] [] [
    make-struct [
        exp: exp
        flags: flags
        fun-def?: false
    ]
]
set-word pick cwords 18 make native! reduce [
    load make string! "exp flags" true
    none
    function [arguments] [exp flags] [
        set [exp flags] arguments
        ast-regexp exp/value flags/value
    ]
]
ast-switch: function [value cases def] [] [
    make-struct [
        value: value
        cases: cases
        def: def
        fun-def?: false
    ]
]
set-word pick cwords 19 make native! reduce [
    load make string! "value cases default" true
    none
    function [arguments] [value cases def expr compiled-cases] [
        set [value cases def] arguments
        cases: cases/value
        def: def/value
        compiled-cases: make-array
        while [not empty? cases] [
            set [expr cases] compile-step cases
            append-array compiled-cases make-struct [
                value: expr
                expr: compile first cases
            ]
            cases: skip cases 1
        ]
        ast-switch value compiled-cases compile def
    ]
]
compile-cases: function [cases] [cond orig-cases] [
    either empty? cases [
        none
    ] [
        orig-cases: cases
        set [cond cases] compile-step cases
        if empty? cases [
            error "Compile" "Missing case block after condition" mold-value orig-cases ""
        ]
        ast-either cond compile first cases compile-cases skip cases 1
    ]
]
set-word pick cwords 20 make native! reduce [
    load make string! "cases" true
    none
    function [arguments] [cases expr] [
        cases: pick-array arguments 0
        if empty? cases/value [
            error "Compile" "CASE needs at least one case" ""
        ]
        compile-cases cases/value
    ]
]
ast-to-char: function [expr] [] [
    make-struct [
        expr: expr
        fun-def?: false
    ]
]
set-word pick cwords 21 make native! reduce [
    load make string! "number" true
    none
    function [arguments] [] [
        ast-to-char pick-array arguments 0
    ]
]
ast-try: function [code word def] [] [
    make-struct [
        code: code
        word: word
        def: def
        fun-def?: false
    ]
]
set-word pick cwords 22 make native! reduce [
    load make string! "code word default" true
    none
    function [arguments] [code word def] [
        set [code word def] arguments
        ast-try compile code/value word/value compile def
    ]
]
ast-op: function [op val1 val2] [] [
    make-struct [
        op: op
        val1: val1
        val2: val2
        fun-def?: false
    ]
]
set-word pick cwords 23 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "+" val1 val2
    ]
]
set-word pick cwords 24 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "==" val1 val2
    ]
]
set-word pick cwords 25 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "-" val1 val2
    ]
]
set-word pick cwords 26 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op ">" val1 val2
    ]
]
set-word pick cwords 27 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "<" val1 val2
    ]
]
set-word pick cwords 28 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "!=" val1 val2
    ]
]
set-word pick cwords 29 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op ">=" val1 val2
    ]
]
set-word pick cwords 30 make op! make native! reduce [
    load make string! "val1 val2" true
    none
    function [arguments] [val1 val2] [
        set [val1 val2] arguments
        ast-op "<=" val1 val2
    ]
]


sys: apply 'require ["sys"]
fs: apply 'require ["fs"]

do load read "topaz/init.topaz" true

either 2 < length-of-array process/argv [
    do load read pick-array process/argv 2 true
] [
    print "Topaz Interpreter - (C) 2011 Gabriele Santilli - MIT License^/"
    stdin: apply 'process/open-stdin []
    apply 'stdin/set-encoding ["utf8"]
    apply 'stdin/add-listener [
        "data"
        function [chunk] [res] [
            either chunk = "quit^/" [
                apply 'stdin/destroy []
            ] [
                try [
                    chunk: do load make string! chunk true
                    print "== " probe chunk
                    print ">> "
                ] 'e [
                    print e + "^/>> "
                ]
            ]
        ]
    ]
    print ">> "
]
