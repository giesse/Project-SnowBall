; Topaz Interpreter Basic Tests

run-test: func [test] [
    prin ">> " print mold* test ">> "
    try [
        test: do test
        prin "== " print mold* :test "== "
    ] 'error [
        print form-error error
    ]
    print ""
]

run-test ['word [1 2 3] (1 2 3) 'lit/path "string" #"C"]
run-test [a: 1 a]
run-test [make datatype! 0]
run-test [insert [] 1]
run-test [head []]
run-test [pick [1 2 3] 1]
run-test [length-of [1 2 3]]
run-test [empty? []]
run-test [skip [1 2 3] 1]
run-test [skip [1 2 3] 2]
run-test [head skip [1 2 3] 2]
run-test [mold [1 2 3]]
run-test [mold 'a/path]
run-test [mold 'a-word]
run-test [do [pick [1 2 3] 1]]
run-test [get 'datatype!]
run-test [get 'make]
run-test [get 'insert]
run-test [get 'block!]
run-test [get 'func]
run-test [:datatype!]
run-test [:make]
run-test [:insert]
run-test [:block!]
run-test [:func]
run-test [tail [1 2 3]]
run-test [probe [1 2 3]]
run-test [make block! 0]
run-test [make paren! 0]
run-test [make path! 0]
run-test [first [1 2 3]]
run-test [make set-path! 0]
run-test [make lit-path! 0]
run-test [make string! 0]
run-test [make char! 64]
run-test [make number! 64]
run-test [make word! "bla"]
run-test [make set-word! "bla"]
run-test [make lit-word! "bla"]
run-test [make function! [[a b] [a]]]
run-test [append [1 2 3] 4]
run-test [make native! [[series value] insert]]
run-test [load "1 2 3"]
run-test [reduce [1 2 3]]
run-test [reduce [get 'datatype! :make :func append [1 2 3] 4]]
run-test [f: func [a b c] [reduce [a b c]]]
run-test [f 1 2 3]
run-test [f 'a 'b 'c]
run-test [f f 1 2 3 f 4 5 6 f 7 8 9]
run-test [load "1 2 3 ; 4 5 6^/ 7 8 9"]
run-test [read "topaz/init.topaz"]
run-test [load read "topaz/init.topaz"]
run-test [1 + 1]
run-test [1 - 1]
run-test [g: func [a b] [probe a probe b a + b] ++: make op! :g]
run-test [1 ++ 1]
run-test [1 > 2]
run-test [1 < 2]
run-test [2 + 2 <= 4]
run-test [compile [a: 1 + 1]]
run-test [
    ; makes 'print local
    compile-test: func [] [
        print: func [text] [make expression! [apply 'print [text]]]
        compile [
            print: function [text] [] [
                apply 'sys/print [text]
                text
            ]
            print "one"
            print "two"
        ]
    ]
    compile-test
]
run-test [write "test.txt" "This is a test"]
run-test [read "test.txt"]
run-test [cause make error! [category: 'Script id: 'user-error message: "An error"]]
run-test [catch [throw "Something" none]]
run-test [if true ["Was true"]]
run-test [if false ["Was true"]]
run-test [either true ["Was true"] ["Was false"]]
run-test [either false ["Was true"] ["Was false"]]
run-test [not true]
run-test [not none]
run-test [i: 0 while [i < 10] [print mold i i: i + 1]]
run-test [all [true false none]]
run-test [all [true false print "Not here"]]
run-test [any [false true]]
run-test [any [none "Default"]]
run-test [case [1 < 0 [print "Wrong"] 1 > 0 [print "Correct"]]]
run-test [read "next/types"]
run-test [context [a: 1 b: 2]]
run-test [
    a: 1 b: 2
    code: [a + b]
    probe do code
    ctx: context [a: 3 b: 4]
    bind code ctx
    probe do code
    context-of first code
]
run-test [[1 2 3] = [1 2 3]]
run-test [[1 2 3 4] = [1 2 3]]
run-test [[1 2 3 4] = [1 2 3 5]]
run-test ['word = first [word]]
run-test ['word = first [word:]]
run-test [[a b "c d e"] = [a b "c d e"]]
run-test ['word1 = 'word2]
run-test ["String 1" = "String 2"]
run-test ["String 1" <> "String 2"]
run-test [make word! 1]
run-test [make word! word!]
run-test [type-of make word! word!]
run-test [type-of word!]
run-test [type-of 1]
run-test [type-of 'word]
run-test [type-of "String"]
run-test [find [1 2 3] 2]
run-test [find [a b c] 'b]
run-test [find [a b c] 'd]
run-test [switch 'a [a [1] b [2] c d [3]] [4]]
run-test [switch 'b [a [1] b [2] c d [3]] [4]]
run-test [switch 'c [a [1] b [2] c d [3]] [4]]
run-test [switch 'd [a [1] b [2] c d [3]] [4]]
run-test [switch 'e [a [1] b [2] c d [3]] [4]]
; bug with skip
run-test [empty? skip [] 1]
; bug with recursive functions
run-test [
    f: func [a] [if a > 1 [f a - 1]]
    f 2
]
run-test [
    a: 1
    until [
        a: a + 1
        a = 5
    ]
    a
]
run-test [parse [1 2 3] [number!]]
run-test [parse [1 2 3] [number! number!]]
run-test [parse [1 2 3] [number! number! number!]]
run-test [parse [1 2 3] [number! number! number! number!]]
run-test [parse [1 2 3] [word!]]
run-test [parse [1 2 3] [some number!]]
run-test [parse [1 2 3] [any number!]]
run-test [parse [1 2 3] [collect some [keep number!]]]
run-test [
    interpreter: load read "topaz/support.topaz"
    parse interpreter [
        collect any [
            keep set-word! [
                'function keep ('funcall-macro) keep block! block! block!
                |
                keep (none)
            ]
            |
            skip
        ]
    ]
]
run-test [parse [a [b c d] e] [word! into [some word!] word!]]
run-test [compose [a b (1 + 1) d]]
run-test [make lit-word! first [name:]]
run-test [
    e: make expression! [1]
    e/value
]
run-test [
    obj: object none [
        one: 1
        two: 2
        three: 1 + 2
        flag
    ]
]
run-test [obj/one]
run-test [obj/three]
run-test [obj/flag]
run-test [obj/four]
run-test [obj/five: 5]
run-test [obj]
run-test [obj2: object obj [four: 4]]
run-test [obj2/one]
run-test [obj2/four]
run-test [obj2/five]
run-test [make error! none]
run-test [try [make datatype! none] 'error [error]]
run-test ['four in obj2]
run-test ['five in obj]
run-test ['four in obj]
run-test ['print in system/words]
run-test [any-word!]
run-test [any-block!]
run-test [word! in any-word!]
run-test [block! in any-word!]
