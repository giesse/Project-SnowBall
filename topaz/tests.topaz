; Topaz Interpreter Basic Tests

run-test: func [test] [
    prin ">> " print mold/options [value: test only indent: ">> "]
    try [
        test: do test
        prin "== " print mold/options [value: :test indent: "== " limit: 1024]
    ] 'error [
        print form-error error
    ]
    print ""
]

run-test ['word [1 2 3] (1 2 3) 'lit/path "string" #"C"]
run-test [a: 1 a]
run-test [make datatype! 0]
run-test [insert [] 1]
run-test [head []]
run-test [pick [1 2 3] 1]
run-test [length-of [1 2 3]]
run-test [empty? []]
run-test [skip [1 2 3] 1]
run-test [skip [1 2 3] 2]
run-test [head skip [1 2 3] 2]
run-test [mold [1 2 3]]
run-test [mold 'a/path]
run-test [mold 'a-word]
run-test [do [pick [1 2 3] 1]]
run-test [get 'datatype!]
run-test [get 'make]
run-test [get 'insert]
run-test [get 'block!]
run-test [get 'func]
run-test [:datatype!]
run-test [:make]
run-test [:insert]
run-test [:block!]
run-test [:func]
run-test [tail [1 2 3]]
run-test [probe [1 2 3]]
run-test [make block! 0]
run-test [make paren! 0]
run-test [make path! 0]
run-test [first [1 2 3]]
run-test [make set-path! 0]
run-test [make lit-path! 0]
run-test [make string! 0]
run-test [make char! 64]
run-test [make number! 64]
run-test [make word! "bla"]
run-test [make set-word! "bla"]
run-test [make lit-word! "bla"]
run-test [make function! [[a b] [a]]]
run-test [append [1 2 3] 4]
run-test [make native! [[series value] insert]]
run-test [load "1 2 3"]
run-test [reduce [1 2 3]]
run-test [reduce [get 'datatype! :make :func append [1 2 3] 4]]
run-test [f: func [a b c] [reduce [a b c]]]
run-test [f 1 2 3]
run-test [f 'a 'b 'c]
run-test [f f 1 2 3 f 4 5 6 f 7 8 9]
run-test [load "1 2 3 ; 4 5 6^/ 7 8 9"]
run-test [read %topaz/init.topaz]
run-test [load read %topaz/init.topaz]
run-test [1 + 1]
run-test [1 - 1]
run-test [g: func [a b] [probe a probe b a + b] ++: make op! :g]
run-test [1 ++ 1]
run-test [1 > 2]
run-test [1 < 2]
run-test [2 + 2 <= 4]
run-test [compile [a: 1 + 1]]
run-test [
    ; makes 'print local
    compile-test: func [] [
        print: func [text] [make expression! [apply :print [text]]]
        compile [
            print: function [text] [] [
                apply sys/print [text]
                text
            ]
            print "one"
            print "two"
        ]
    ]
    compile-test
]
run-test [write %test.txt "This is a test"]
run-test [read %test.txt]
run-test [cause make error! [category: 'Script id: 'user-error message: "An error"]]
run-test [catch [throw "Something" none]]
run-test [if true ["Was true"]]
run-test [if false ["Was true"]]
run-test [either true ["Was true"] ["Was false"]]
run-test [either false ["Was true"] ["Was false"]]
run-test [not true]
run-test [not none]
run-test [i: 0 while [i < 10] [print mold i i: i + 1]]
run-test [all [true false none]]
run-test [all [true false print "Not here"]]
run-test [any [false true]]
run-test [any [none "Default"]]
run-test [case [1 < 0 [print "Wrong"] 1 > 0 [print "Correct"]]]
run-test [read %next/types]
run-test [context [a: 1 b: 2]]
run-test [
    a: 1 b: 2
    code: [a + b]
    probe do code
    ctx: context [a: 3 b: 4]
    bind code ctx
    probe do code
    context-of first code
]
run-test [[1 2 3] = [1 2 3]]
run-test [[1 2 3 4] = [1 2 3]]
run-test [[1 2 3 4] = [1 2 3 5]]
run-test ['word = first [word]]
run-test ['word = first [word:]]
run-test [[a b "c d e"] = [a b "c d e"]]
run-test ['word1 = 'word2]
run-test ["String 1" = "String 2"]
run-test ["String 1" <> "String 2"]
run-test [make word! 1]
run-test [make word! word!]
run-test [type-of make word! word!]
run-test [type-of word!]
run-test [type-of 1]
run-test [type-of 'word]
run-test [type-of "String"]
run-test [find [1 2 3] 2]
run-test [find [a b c] 'b]
run-test [find [a b c] 'd]
run-test [switch-default 'a [a [1] b [2] c d [3]] [4]]
run-test [switch-default 'b [a [1] b [2] c d [3]] [4]]
run-test [switch-default 'c [a [1] b [2] c d [3]] [4]]
run-test [switch-default 'd [a [1] b [2] c d [3]] [4]]
run-test [switch-default 'e [a [1] b [2] c d [3]] [4]]
; bug with skip
run-test [empty? skip [] 1]
; bug with recursive functions
run-test [
    f: func [a] [if a > 1 [f a - 1]]
    f 2
]
run-test [
    a: 1
    until [
        a: a + 1
        a = 5
    ]
    a
]
run-test [parse [1 2 3] [number!]]
run-test [parse [1 2 3] [number! number!]]
run-test [parse [1 2 3] [number! number! number!]]
run-test [parse [1 2 3] [number! number! number! number!]]
run-test [parse [1 2 3] [word!]]
run-test [parse [1 2 3] [some number!]]
run-test [parse [1 2 3] [any number!]]
run-test [parse [1 2 3] [collect some [keep number!]]]
run-test [
    interpreter: load read %topaz/support.topaz
    parse interpreter [
        collect any [
            keep set-word! [
                'function keep ('funcall-macro) keep/only block! block! block!
                |
                keep (none)
            ]
            |
            skip
        ]
    ]
]
run-test [parse [a [b c d] e] [word! into [some word!] word!]]
run-test [compose [a b (1 + 1) d]]
run-test [make lit-word! first [name:]]
run-test [
    e: make expression! [1]
    e/value
]
run-test [
    obj: object none [
        one: 1
        two: 2
        three: 1 + 2
        flag
    ]
]
run-test [obj/one]
run-test [obj/three]
run-test [obj/flag]
run-test [obj/four]
run-test [obj/five: 5]
run-test [obj]
run-test [obj2: object obj [four: 4]]
run-test [obj2/one]
run-test [obj2/four]
run-test [obj2/five]
run-test [make error! none]
run-test [try [make datatype! none] 'error [error]]
run-test ['four in obj2]
run-test ['five in obj]
run-test ['four in obj]
run-test ['print in system/words]
run-test [any-word!]
run-test [any-block!]
run-test [word! in any-word!]
run-test [block! in any-word!]
run-test [
    f: func [
        "This is a test function"
        a [number!] "A number"
        b [any-word!] "A word"
    ] [
        print rejoin ["A: " mold a]
        print rejoin ["B: " mold b]
    ]
]
run-test [f 1 'word]
run-test [f 'word 1]
run-test [f 1 2]
run-test [
    f: func [
        "This is a test function"
        a [number!] "A number"
        b "Anything"
        options:
            c [word!] "A word"
            d: 1 "Anything, default 1"
            e: 'bla [any-word!] "Only words"
    ] [
        print rejoin ["A: " mold a]
        print rejoin ["B: " mold b]
        print rejoin ["C: " mold c]
        print rejoin ["D: " mold d]
        print rejoin ["E: " mold e]
    ]
]
run-test [f 1 'word]
run-test [f 'word 1]
run-test [f 1 2]
run-test [f/c 1 2]
run-test [f/d 1 2]
run-test [
    f/options [
        a: 1
        b: "something"
        c: 'bla
    ]
]
run-test [
    f/options [
        a: 1
        b: "something"
        c: 1
    ]
]
run-test [
    f/options [
        a: 1
        b: "something"
        d: "something else"
        e: first [set-word:]
    ]
]
run-test [
    f/options [
        d: "something else"
        e: first [set-word:]
    ]
]
run-test [
    f/options [
        b: "something"
        d: "something else"
        e: first [set-word:]
        a: 1
    ]
]
run-test [
    f: func [
        "This is a test function"
        a [number!] "A number"
        b "Anything"
        c [word!] "A word"
        d "Anything"
        e [any-word!] "Only words"
    ] [
        print rejoin ["A: " mold a]
        print rejoin ["B: " mold b]
        print rejoin ["C: " mold c]
        print rejoin ["D: " mold d]
        print rejoin ["E: " mold e]
    ]
]
run-test [f 1 2 3 4 5]
run-test [
    f [
        b: 1
        a: 2
        c: 'bla
        d: 3
        e: first ['bla]
    ]
]
run-test [
    f [
        a: 1
        b
        c: 'bla
        d
        e: 'bla
    ]
]
run-test [mold [1 2 3]]
run-test [mold [1
2 3]]
run-test [mold/options [value: [1
2 3] indent: "X"]]
run-test [mold/options [value: [1
2 [3 4
5] 6] indent: "X"]]
run-test [mold/only [1 2 3]]
run-test [mold/only [1
2 3]]
run-test [mold/options [value: [1
2 3] indent: "X" only]]
run-test [mold/options [value: [1
2 [3 4
5] 6] indent: "X" only]]
run-test [mold/flat [1 2 3]]
run-test [mold/flat [1
2 3]]
run-test [mold/options [value: [1
2 3] indent: "X" flat]]
run-test [mold/options [value: [1
2 [3 4
5] 6] indent: "X" flat]]
run-test [compose [1 2 ([3 4]) 5 6]]
run-test [compose/only [1 2 ([3 4]) 5 6]]
run-test [compose/deep [1 2 [3 (2 + 2)] 5 6]]
run-test [compose/deep/only [1 2 [3 ([4])] 5 6]]
run-test [parse [a b c d] [word! [number!] | word! word!]]
