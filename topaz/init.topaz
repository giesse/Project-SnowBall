; Topaz Interpreter Initialization

make: conjure 'make
native!: conjure 'native!

foreach: make native! [[words series body] foreach]
set: make native! [[word value] set]
reduce: make native! [[block] reduce]

foreach [native spec] [
    insert            [series value]
    head              [series]
    pick              [series pos]
    length-of         [series]
    skip              [series amount]
    mold              [value]
    do                [block]
    get               [word]
    bind              [words context]
    tail              [series]
    print             [string]
    prin              [string]
    load              [string]
    read              [filename]
    try               [code word default]
    add               [val1 val2]
    subtract          [val1 val2]
    equal?            [val1 val2]
    greater?          [val1 val2]
    lesser?           [val1 val2]
    not-equal?        [val1 val2]
    greater-or-equal? [val1 val2]
    lesser-or-equal?  [val1 val2]
    compile           [block]
    write             [filename text]
    throw             [string]
    if                [condition body]
    either            [condition true-body false-body]
    not               [value]
    apply             [func args]
    while             [condblock body]
    all               [block]
    any               [block]
    switch            [value cases default]
    case              [cases]
    context-of        [word]
    rejoin            [block]
] [
    set native make native! reduce [spec native]
]

foreach 'word [
    datatype! block! paren! path! set-path! lit-path! string! char! number! word! set-word! lit-word! function! op!
    none! logic! context!
] [
    set word conjure word
]

foreach [op f] [
    +  add
    -  subtract
    =  equal?
    >  greater?
    <  lesser?
    <> not-equal?
    >= greater-or-equal?
    <= lesser-or-equal?
] [
    set op make op! get f
]

system: make context! [
    name: "Topaz"
    version: "alpha"
    words: conjure 'system-words
    compiler-words: conjure 'compile-words
    datatypes: reduce [
        datatype! block! paren! path! set-path! lit-path! string! char! number! word! set-word! lit-word! function! op!
        none! logic! context! native!
    ]
]

none: make none! 0
true: on: yes: 0 = 0
false: off: no: 0 = 1

func: make function! [[spec body] [make function! reduce [spec body]]]

first: func [series] [pick series 0]
empty?: func [series] [0 = length-of series]
probe: func [value] [
    print mold get 'value
    get 'value
]
append: func [series value] [head insert tail series value]
context: func [code] [make context! code]

; Compiler initialization

; this is only used because it will bind the words as a side effect
compile [
    throw set if either not apply reduce while all any switch case try + = - > < <> >= <=
    function none true false make-struct make-array poke-array pick-array regexp to-char rejoin 
]

foreach 'word [
    throw set if either not apply reduce while all any switch case try + = - > < <> >= <=
] [
    value: get word
    set bind word system/compiler-words get 'value
]

foreach [word spec] [
    function    [spec locals body]
    none        []
    true        []
    false       []
    make-struct [spec]
    make-array  []
    poke-array  [array position value]
    pick-array  [array position]
    regexp      [exp flags]
    to-char     [number]
    rejoin      [block]
] [
    set bind word system/compiler-words make native! reduce [spec word]
]
