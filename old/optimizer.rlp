Optimizer (middle-end) for the Topaz language compiler

    Type: Module
    Purpose: {
        Defines the niwashi rules that optimize trees
        parsed from Topaz code blocks.
    }
    Author: "Gabriele Santilli"
    File: %optimizer.r
    Version: 1.0.0
    Imports: [
        %bootstrap/niwashi.r
        %bootstrap/trees.r
        %bootstrap/collect.r
    ]
    Exports: [
        optimizer-rules
    ]

===Introduction

This program defines the niwashi rules that can be used by the parser
to produce an optimized tree. Documentation is still scarce (and will probably
stay this way until successful compiler bootstrap).

===Overview

    -main-:
    -support-functions-

    optimizer-rules: [
        always [
            -basic-expansion-
        ]
        ;-paren-
    ]

===Expansion of macros and other special constructs

    -basic-expansion-:
    on macro expand-macro
    on apply expand-apply

---Macro expansion

    -macro-expansion-:
    expand-macro: func [node /local m niwashi args] [
        args: make-args-map node
        m: get-node node/prop/value
        niwashi: make-niwashi
        define-rules niwashi optimizer-rules
        process-node niwashi m args
        set-node node/next: niwashi/root
        set-node node/parent: none
        node: niwashi/root
        set-node node/type: 'paren!
        true
    ]
    make-args-map: func [node /local args] [
        collect [
            foreach ref get-node node/prop/refs [
                keep ref
                keep/only make-tree [logic! [value: true]]
            ]
            args: get-node node/childs
            foreach arg get-node node/prop/args [
                keep arg
                keep/only args/1
                args: next args
            ]
        ]
    ]
    process-node: func [niwashi node args /local arg arg-value] [
        switch/default get-node node/type [
            root [
                foreach child get-node node/childs [
                    process-node niwashi child args
                ]
            ]
            argument [
                either path? arg: get-node node/prop/value [
                    ; Fixme
                    make error! "Not yet supported"
                ] [
                    ; Fixme: this does not really work
                    either arg-value: select args arg [
                        niclone niwashi arg-value :niclone
                    ] [
                        append-child niwashi [type: 'none! properties: [value: none]]
                    ]
                ]
            ]
        ] [
            niclone niwashi node func [niwashi node f] [process-node niwashi node args]
        ]
    ]

---|apply| call expansion

    -apply-expansion-:
    expand-apply: func [node /local f f-spec f-path f-node args val] [
        f: get-node node/childs/1
        args: next get-node node/childs
        ; Fixme: literal? other?
        either 'get-word! = get-node f/type [
            f-path: to path! to word! get-node f/prop/value
            unless any-function? f: get/any get-node f/prop/value [make error! "APPLY needs a function"]
        ] [
            make error! "Dynamic APPLY not yet implemented"
        ]
        f-spec: first :f
        f-node: make-node 'function
        set-node node/previous: f-node
        set-node node/parent: none
        ; Fixme: refinements don't work
        while [not tail? f-spec] [
            either refinement? f-spec/1 [
                either refinement-set? args val: to word! f-spec/1 [
                    append f-path val
                    f-spec: next f-spec
                ] [
                    f-spec: any [find next f-spec refinement! tail f-spec]
                ]
            ] [
                ; Fixme: type check
                either val: get-argument-value args f-spec/1 [
                    set-node val/parent: f-node
                ] [
                    val: make-node 'none!
                    set-node val/prop/value: none
                    set-node val/parent: f-node
                ]
                f-spec: next f-spec
            ]
        ]
        set-node f-node/prop/value: either 1 = length? f-path [:f] [f-path]
    ]
    get-argument-value: func [args name] [
        foreach arg args [
            if name = get-node arg/prop/name [
                return get-node arg/childs/1
            ]
        ]
    ]
    refinement-set?: func [args name] [
        foreach arg args [
            if name = get-node arg/prop/name [
                ; Fixme
                return 'refinement = get-node arg/type
            ]
        ]
    ]
    
===Support functions

    -support-functions-:
    -macro-expansion-
    -apply-expansion-
    niclone: func [niwashi [object!] tree [block!] f [function!]] [
        enter-child niwashi [type: get-node tree/type properties: get-node tree/properties]
        foreach child get-node tree/childs [
            f niwashi child :f
        ]
        leave-child niwashi
    ]
